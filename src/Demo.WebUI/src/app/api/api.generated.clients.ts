/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.5.0 (NJsonSchema v10.6.6.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
// @ts-nocheck

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class ApiApplicationSettingsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(query?: GetApplicationSettingsQuery | null | undefined): Observable<GetApplicationSettingsQueryResult> {
        let url_ = this.baseUrl + "/api/ApplicationSettings?";
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GetApplicationSettingsQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetApplicationSettingsQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetApplicationSettingsQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetApplicationSettingsQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetApplicationSettingsQueryResult>(<any>null);
    }

    save(command: SaveApplicationSettingsCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/ApplicationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getApplicationSettingsAuditlog(pageIndex?: number | undefined, pageSize?: number | undefined): Observable<GetApplicationSettingsAuditlogQueryResult> {
        let url_ = this.baseUrl + "/api/ApplicationSettings/Auditlog?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApplicationSettingsAuditlog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApplicationSettingsAuditlog(<any>response_);
                } catch (e) {
                    return <Observable<GetApplicationSettingsAuditlogQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetApplicationSettingsAuditlogQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetApplicationSettingsAuditlog(response: HttpResponseBase): Observable<GetApplicationSettingsAuditlogQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetApplicationSettingsAuditlogQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetApplicationSettingsAuditlogQueryResult>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiCurrentUserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCurrentUserDetails(): Observable<GetUserByIdQueryResult> {
        let url_ = this.baseUrl + "/api/CurrentUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserDetails(<any>response_);
                } catch (e) {
                    return <Observable<GetUserByIdQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserByIdQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUserDetails(response: HttpResponseBase): Observable<GetUserByIdQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserByIdQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserByIdQueryResult>(<any>null);
    }

    getCurrentUserFeatureFlags(query?: GetCurrentUserFeatureFlagsQuery | null | undefined): Observable<GetCurrentUserFeatureFlagsQueryResult> {
        let url_ = this.baseUrl + "/api/CurrentUser/FeatureFlags?";
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserFeatureFlags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserFeatureFlags(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentUserFeatureFlagsQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentUserFeatureFlagsQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUserFeatureFlags(response: HttpResponseBase): Observable<GetCurrentUserFeatureFlagsQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentUserFeatureFlagsQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentUserFeatureFlagsQueryResult>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiCustomersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    search(orderBy?: SearchCustomersOrderByEnum | undefined, orderByDescending?: boolean | undefined, pageIndex?: number | undefined, pageSize?: number | undefined, searchTerm?: string | null | undefined): Observable<SearchCustomersQueryResult> {
        let url_ = this.baseUrl + "/api/Customers?";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderByDescending === null)
            throw new Error("The parameter 'orderByDescending' cannot be null.");
        else if (orderByDescending !== undefined)
            url_ += "OrderByDescending=" + encodeURIComponent("" + orderByDescending) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<SearchCustomersQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SearchCustomersQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SearchCustomersQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchCustomersQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchCustomersQueryResult>(<any>null);
    }

    create(command: CreateCustomerCommand): Observable<CreateCustomerResponse> {
        let url_ = this.baseUrl + "/api/Customers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CreateCustomerResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateCustomerResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateCustomerResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreateCustomerResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateCustomerResponse>(<any>null);
    }

    getCustomerById(id: string): Observable<GetCustomerByIdQueryResult> {
        let url_ = this.baseUrl + "/api/Customers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerById(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerByIdQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerByIdQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerById(response: HttpResponseBase): Observable<GetCustomerByIdQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerByIdQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerByIdQueryResult>(<any>null);
    }

    update(id: string, command: UpdateCustomerCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Customers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    delete(id: string, command: DeleteCustomerCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Customers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getCustomerAuditlog(id: string, pageIndex?: number | undefined, pageSize?: number | undefined): Observable<GetCustomerAuditlogQueryResult> {
        let url_ = this.baseUrl + "/api/Customers/{id}/Auditlog?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerAuditlog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerAuditlog(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerAuditlogQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerAuditlogQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerAuditlog(response: HttpResponseBase): Observable<GetCustomerAuditlogQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerAuditlogQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerAuditlogQueryResult>(<any>null);
    }

    lookup(orderBy?: CustomerLookupOrderByEnum | undefined, orderByDescending?: boolean | undefined, pageIndex?: number | undefined, pageSize?: number | undefined, searchTerm?: string | null | undefined, ids?: string[] | null | undefined): Observable<CustomerLookupQueryResult> {
        let url_ = this.baseUrl + "/api/Customers/Lookup?";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderByDescending === null)
            throw new Error("The parameter 'orderByDescending' cannot be null.");
        else if (orderByDescending !== undefined)
            url_ += "OrderByDescending=" + encodeURIComponent("" + orderByDescending) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLookup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLookup(<any>response_);
                } catch (e) {
                    return <Observable<CustomerLookupQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerLookupQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processLookup(response: HttpResponseBase): Observable<CustomerLookupQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerLookupQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerLookupQueryResult>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiFeatureFlagSettingsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(query?: GetFeatureFlagSettingsQuery | null | undefined): Observable<GetFeatureFlagSettingsQueryResult> {
        let url_ = this.baseUrl + "/api/FeatureFlagSettings?";
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GetFeatureFlagSettingsQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetFeatureFlagSettingsQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetFeatureFlagSettingsQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetFeatureFlagSettingsQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFeatureFlagSettingsQueryResult>(<any>null);
    }

    save(command: SaveFeatureFlagSettingsCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/FeatureFlagSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getFeatureFlagSettingsAuditlog(pageIndex?: number | undefined, pageSize?: number | undefined): Observable<GetFeatureFlagSettingsAuditlogQueryResult> {
        let url_ = this.baseUrl + "/api/FeatureFlagSettings/Auditlog?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFeatureFlagSettingsAuditlog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFeatureFlagSettingsAuditlog(<any>response_);
                } catch (e) {
                    return <Observable<GetFeatureFlagSettingsAuditlogQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetFeatureFlagSettingsAuditlogQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetFeatureFlagSettingsAuditlog(response: HttpResponseBase): Observable<GetFeatureFlagSettingsAuditlogQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetFeatureFlagSettingsAuditlogQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFeatureFlagSettingsAuditlogQueryResult>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiInvoicesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    search(orderBy?: SearchInvoicesOrderByEnum | undefined, orderByDescending?: boolean | undefined, pageIndex?: number | undefined, pageSize?: number | undefined, searchTerm?: string | null | undefined, status?: InvoiceStatusEnum | null | undefined): Observable<SearchInvoicesQueryResult> {
        let url_ = this.baseUrl + "/api/Invoices?";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderByDescending === null)
            throw new Error("The parameter 'orderByDescending' cannot be null.");
        else if (orderByDescending !== undefined)
            url_ += "OrderByDescending=" + encodeURIComponent("" + orderByDescending) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<SearchInvoicesQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SearchInvoicesQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SearchInvoicesQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchInvoicesQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchInvoicesQueryResult>(<any>null);
    }

    create(command: CreateInvoiceCommand): Observable<CreateInvoiceResponse> {
        let url_ = this.baseUrl + "/api/Invoices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CreateInvoiceResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateInvoiceResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateInvoiceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreateInvoiceResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateInvoiceResponse>(<any>null);
    }

    getInvoiceById(id: string): Observable<GetInvoiceByIdQueryResult> {
        let url_ = this.baseUrl + "/api/Invoices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceById(<any>response_);
                } catch (e) {
                    return <Observable<GetInvoiceByIdQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetInvoiceByIdQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceById(response: HttpResponseBase): Observable<GetInvoiceByIdQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInvoiceByIdQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInvoiceByIdQueryResult>(<any>null);
    }

    update(id: string, command: UpdateInvoiceCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Invoices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    delete(id: string, command: DeleteInvoiceCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Invoices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    markAsSent(id: string, command: MarkInvoiceAsSentCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Invoices/{id}/MarkAsSent";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAsSent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsSent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAsSent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    markAsPaid(id: string, command: MarkInvoiceAsPaidCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Invoices/{id}/MarkAsPaid";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAsPaid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsPaid(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAsPaid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    markAsCancelled(id: string, command: MarkInvoiceAsCancelledCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Invoices/{id}/MarkAsCancelled";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAsCancelled(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsCancelled(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAsCancelled(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getInvoiceAuditlog(id: string, pageIndex?: number | undefined, pageSize?: number | undefined): Observable<GetInvoiceAuditlogQueryResult> {
        let url_ = this.baseUrl + "/api/Invoices/{id}/Auditlog?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceAuditlog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceAuditlog(<any>response_);
                } catch (e) {
                    return <Observable<GetInvoiceAuditlogQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetInvoiceAuditlogQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceAuditlog(response: HttpResponseBase): Observable<GetInvoiceAuditlogQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInvoiceAuditlogQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInvoiceAuditlogQueryResult>(<any>null);
    }

    copy(id: string, command: CopyInvoiceCommand): Observable<CopyInvoiceResponse> {
        let url_ = this.baseUrl + "/api/Invoices/{id}/Copy";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCopy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopy(<any>response_);
                } catch (e) {
                    return <Observable<CopyInvoiceResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CopyInvoiceResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCopy(response: HttpResponseBase): Observable<CopyInvoiceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CopyInvoiceResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CopyInvoiceResponse>(<any>null);
    }

    credit(id: string, command: CreditInvoiceCommand): Observable<CreditInvoiceResponse> {
        let url_ = this.baseUrl + "/api/Invoices/{id}/Credit";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCredit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCredit(<any>response_);
                } catch (e) {
                    return <Observable<CreditInvoiceResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreditInvoiceResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCredit(response: HttpResponseBase): Observable<CreditInvoiceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreditInvoiceResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreditInvoiceResponse>(<any>null);
    }

    lookup(orderBy?: InvoiceLookupOrderByEnum | undefined, orderByDescending?: boolean | undefined, pageIndex?: number | undefined, pageSize?: number | undefined, searchTerm?: string | null | undefined, ids?: string[] | null | undefined): Observable<InvoiceLookupQueryResult> {
        let url_ = this.baseUrl + "/api/Invoices/Lookup?";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderByDescending === null)
            throw new Error("The parameter 'orderByDescending' cannot be null.");
        else if (orderByDescending !== undefined)
            url_ += "OrderByDescending=" + encodeURIComponent("" + orderByDescending) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLookup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLookup(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceLookupQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceLookupQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processLookup(response: HttpResponseBase): Observable<InvoiceLookupQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceLookupQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceLookupQueryResult>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiLogClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    post(logMessages: LogMessage[]): Observable<void> {
        let url_ = this.baseUrl + "/api/Log";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(logMessages);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiRolesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    search(orderBy?: SearchRoleOrderByEnum | undefined, orderByDescending?: boolean | undefined, pageIndex?: number | undefined, pageSize?: number | undefined, searchTerm?: string | null | undefined): Observable<SearchRolesQueryResult> {
        let url_ = this.baseUrl + "/api/Roles?";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderByDescending === null)
            throw new Error("The parameter 'orderByDescending' cannot be null.");
        else if (orderByDescending !== undefined)
            url_ += "OrderByDescending=" + encodeURIComponent("" + orderByDescending) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<SearchRolesQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SearchRolesQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SearchRolesQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchRolesQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchRolesQueryResult>(<any>null);
    }

    create(command: CreateRoleCommand): Observable<CreateRoleResponse> {
        let url_ = this.baseUrl + "/api/Roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CreateRoleResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateRoleResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateRoleResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreateRoleResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateRoleResponse>(<any>null);
    }

    getRoleById(id: string): Observable<GetRoleByIdQueryResult> {
        let url_ = this.baseUrl + "/api/Roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleById(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleByIdQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleByIdQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleById(response: HttpResponseBase): Observable<GetRoleByIdQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleByIdQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleByIdQueryResult>(<any>null);
    }

    update(id: string, command: UpdateRoleCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    delete(id: string, command: DeleteRoleCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getRoleAuditlog(id: string, pageIndex?: number | undefined, pageSize?: number | undefined): Observable<GetRoleAuditlogQueryResult> {
        let url_ = this.baseUrl + "/api/Roles/{id}/Auditlog?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleAuditlog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleAuditlog(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleAuditlogQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleAuditlogQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleAuditlog(response: HttpResponseBase): Observable<GetRoleAuditlogQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleAuditlogQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleAuditlogQueryResult>(<any>null);
    }

    lookup(orderBy?: RoleLookupOrderByEnum | undefined, orderByDescending?: boolean | undefined, pageIndex?: number | undefined, pageSize?: number | undefined, searchTerm?: string | null | undefined, ids?: string[] | null | undefined): Observable<RoleLookupQueryResult> {
        let url_ = this.baseUrl + "/api/Roles/Lookup?";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderByDescending === null)
            throw new Error("The parameter 'orderByDescending' cannot be null.");
        else if (orderByDescending !== undefined)
            url_ += "OrderByDescending=" + encodeURIComponent("" + orderByDescending) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLookup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLookup(<any>response_);
                } catch (e) {
                    return <Observable<RoleLookupQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleLookupQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processLookup(response: HttpResponseBase): Observable<RoleLookupQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleLookupQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleLookupQueryResult>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiUserPreferencesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(query?: GetUserPreferencesQuery | null | undefined): Observable<GetUserPreferencesQueryResult> {
        let url_ = this.baseUrl + "/api/UserPreferences?";
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPreferencesQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPreferencesQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetUserPreferencesQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserPreferencesQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPreferencesQueryResult>(<any>null);
    }

    save(command: SaveUserPreferencesCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/UserPreferences";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getUserPreferencesAuditlog(pageIndex?: number | undefined, pageSize?: number | undefined): Observable<GetUserPreferencesAuditlogQueryResult> {
        let url_ = this.baseUrl + "/api/UserPreferences/Auditlog?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPreferencesAuditlog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPreferencesAuditlog(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPreferencesAuditlogQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPreferencesAuditlogQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPreferencesAuditlog(response: HttpResponseBase): Observable<GetUserPreferencesAuditlogQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserPreferencesAuditlogQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPreferencesAuditlogQueryResult>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    search(orderBy?: SearchUserOrderByEnum | undefined, orderByDescending?: boolean | undefined, pageIndex?: number | undefined, pageSize?: number | undefined, searchTerm?: string | null | undefined): Observable<SearchUsersQueryResult> {
        let url_ = this.baseUrl + "/api/Users?";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderByDescending === null)
            throw new Error("The parameter 'orderByDescending' cannot be null.");
        else if (orderByDescending !== undefined)
            url_ += "OrderByDescending=" + encodeURIComponent("" + orderByDescending) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<SearchUsersQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SearchUsersQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SearchUsersQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchUsersQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchUsersQueryResult>(<any>null);
    }

    create(command: CreateUserCommand): Observable<CreateUserResponse> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CreateUserResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateUserResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateUserResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreateUserResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateUserResponse>(<any>null);
    }

    getUserById(id: string): Observable<GetUserByIdQueryResult> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserById(<any>response_);
                } catch (e) {
                    return <Observable<GetUserByIdQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserByIdQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserById(response: HttpResponseBase): Observable<GetUserByIdQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserByIdQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserByIdQueryResult>(<any>null);
    }

    update(id: string, command: UpdateUserCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    delete(id: string, command: DeleteUserCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getUserAuditlog(id: string, pageIndex?: number | undefined, pageSize?: number | undefined): Observable<GetUserAuditlogQueryResult> {
        let url_ = this.baseUrl + "/api/Users/{id}/Auditlog?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserAuditlog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserAuditlog(<any>response_);
                } catch (e) {
                    return <Observable<GetUserAuditlogQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserAuditlogQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserAuditlog(response: HttpResponseBase): Observable<GetUserAuditlogQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserAuditlogQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserAuditlogQueryResult>(<any>null);
    }

    lookup(orderBy?: UserLookupOrderByEnum | undefined, orderByDescending?: boolean | undefined, pageIndex?: number | undefined, pageSize?: number | undefined, searchTerm?: string | null | undefined, ids?: string[] | null | undefined): Observable<UserLookupQueryResult> {
        let url_ = this.baseUrl + "/api/Users/Lookup?";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderByDescending === null)
            throw new Error("The parameter 'orderByDescending' cannot be null.");
        else if (orderByDescending !== undefined)
            url_ += "OrderByDescending=" + encodeURIComponent("" + orderByDescending) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLookup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLookup(<any>response_);
                } catch (e) {
                    return <Observable<UserLookupQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserLookupQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processLookup(response: HttpResponseBase): Observable<UserLookupQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserLookupQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserLookupQueryResult>(<any>null);
    }

    isEmailAvailable(email?: string | null | undefined, ignoreId?: string | null | undefined): Observable<IsEmailAvailableQueryResult> {
        let url_ = this.baseUrl + "/api/Users/IsEmailAvailable?";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (ignoreId !== undefined && ignoreId !== null)
            url_ += "IgnoreId=" + encodeURIComponent("" + ignoreId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsEmailAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsEmailAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsEmailAvailableQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsEmailAvailableQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processIsEmailAvailable(response: HttpResponseBase): Observable<IsEmailAvailableQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsEmailAvailableQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsEmailAvailableQueryResult>(<any>null);
    }
}

export class GetApplicationSettingsQueryResult implements IGetApplicationSettingsQueryResult {
    applicationSettings?: ApplicationSettingsDto | undefined;

    constructor(data?: IGetApplicationSettingsQueryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationSettings = _data["applicationSettings"] ? ApplicationSettingsDto.fromJS(_data["applicationSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetApplicationSettingsQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetApplicationSettingsQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationSettings"] = this.applicationSettings ? this.applicationSettings.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetApplicationSettingsQueryResult {
        const json = this.toJSON();
        let result = new GetApplicationSettingsQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetApplicationSettingsQueryResult {
    applicationSettings?: ApplicationSettingsDto | undefined;
}

export class EntityDto implements IEntityDto {
    timestamp?: string | undefined;
    id!: string;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp;
        data["id"] = this.id;
        return data;
    }

    clone(): EntityDto {
        const json = this.toJSON();
        let result = new EntityDto();
        result.init(json);
        return result;
    }
}

export interface IEntityDto {
    timestamp?: string | undefined;
    id: string;
}

export class AuditableEntityDto extends EntityDto implements IAuditableEntityDto {
    createdBy?: string | undefined;
    createdOn!: Date;
    lastModifiedBy?: string | undefined;
    lastModifiedOn?: Date | undefined;

    constructor(data?: IAuditableEntityDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedOn = _data["lastModifiedOn"] ? new Date(_data["lastModifiedOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuditableEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditableEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedOn"] = this.lastModifiedOn ? this.lastModifiedOn.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): AuditableEntityDto {
        const json = this.toJSON();
        let result = new AuditableEntityDto();
        result.init(json);
        return result;
    }
}

export interface IAuditableEntityDto extends IEntityDto {
    createdBy?: string | undefined;
    createdOn: Date;
    lastModifiedBy?: string | undefined;
    lastModifiedOn?: Date | undefined;
}

export class ApplicationSettingsDto extends AuditableEntityDto implements IApplicationSettingsDto {
    settings?: ApplicationSettingsSettingsDto | undefined;

    constructor(data?: IApplicationSettingsDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.settings = _data["settings"] ? ApplicationSettingsSettingsDto.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): ApplicationSettingsDto {
        const json = this.toJSON();
        let result = new ApplicationSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationSettingsDto extends IAuditableEntityDto {
    settings?: ApplicationSettingsSettingsDto | undefined;
}

export class ApplicationSettingsSettingsDto implements IApplicationSettingsSettingsDto {
    setting1!: boolean;
    setting2?: string | undefined;
    setting3!: Date;
    setting4!: string;
    setting5!: number;

    constructor(data?: IApplicationSettingsSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setting1 = _data["setting1"];
            this.setting2 = _data["setting2"];
            this.setting3 = _data["setting3"] ? new Date(_data["setting3"].toString()) : <any>undefined;
            this.setting4 = _data["setting4"];
            this.setting5 = _data["setting5"];
        }
    }

    static fromJS(data: any): ApplicationSettingsSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationSettingsSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting1"] = this.setting1;
        data["setting2"] = this.setting2;
        data["setting3"] = this.setting3 ? this.setting3.toISOString() : <any>undefined;
        data["setting4"] = this.setting4;
        data["setting5"] = this.setting5;
        return data;
    }

    clone(): ApplicationSettingsSettingsDto {
        const json = this.toJSON();
        let result = new ApplicationSettingsSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationSettingsSettingsDto {
    setting1: boolean;
    setting2?: string | undefined;
    setting3: Date;
    setting4: string;
    setting5: number;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }

    clone(): ProblemDetails {
        const json = this.toJSON();
        let result = new ProblemDetails();
        result.init(json);
        return result;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class GetApplicationSettingsQuery implements IGetApplicationSettingsQuery {

    constructor(data?: IGetApplicationSettingsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetApplicationSettingsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetApplicationSettingsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): GetApplicationSettingsQuery {
        const json = this.toJSON();
        let result = new GetApplicationSettingsQuery();
        result.init(json);
        return result;
    }
}

export interface IGetApplicationSettingsQuery {
}

export class ValidationProblemDetails extends ProblemDetails implements IValidationProblemDetails {
    errors?: { [key: string]: string[]; } | undefined;

    constructor(data?: IValidationProblemDetails) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = this.errors[key];
            }
        }
        super.toJSON(data);
        return data;
    }

    clone(): ValidationProblemDetails {
        const json = this.toJSON();
        let result = new ValidationProblemDetails();
        result.init(json);
        return result;
    }
}

export interface IValidationProblemDetails extends IProblemDetails {
    errors?: { [key: string]: string[]; } | undefined;
}

export class SaveApplicationSettingsCommand implements ISaveApplicationSettingsCommand {
    timestamp?: string | undefined;
    settings?: SaveApplicationSettingsSettingsDto | undefined;

    constructor(data?: ISaveApplicationSettingsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"];
            this.settings = _data["settings"] ? SaveApplicationSettingsSettingsDto.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SaveApplicationSettingsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SaveApplicationSettingsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp;
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        return data;
    }

    clone(): SaveApplicationSettingsCommand {
        const json = this.toJSON();
        let result = new SaveApplicationSettingsCommand();
        result.init(json);
        return result;
    }
}

export interface ISaveApplicationSettingsCommand {
    timestamp?: string | undefined;
    settings?: SaveApplicationSettingsSettingsDto | undefined;
}

export class SaveApplicationSettingsSettingsDto implements ISaveApplicationSettingsSettingsDto {
    setting1!: boolean;
    setting2?: string | undefined;
    setting3!: Date;
    setting4!: string;
    setting5!: number;

    constructor(data?: ISaveApplicationSettingsSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setting1 = _data["setting1"];
            this.setting2 = _data["setting2"];
            this.setting3 = _data["setting3"] ? new Date(_data["setting3"].toString()) : <any>undefined;
            this.setting4 = _data["setting4"];
            this.setting5 = _data["setting5"];
        }
    }

    static fromJS(data: any): SaveApplicationSettingsSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveApplicationSettingsSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting1"] = this.setting1;
        data["setting2"] = this.setting2;
        data["setting3"] = this.setting3 ? this.setting3.toISOString() : <any>undefined;
        data["setting4"] = this.setting4;
        data["setting5"] = this.setting5;
        return data;
    }

    clone(): SaveApplicationSettingsSettingsDto {
        const json = this.toJSON();
        let result = new SaveApplicationSettingsSettingsDto();
        result.init(json);
        return result;
    }
}

export interface ISaveApplicationSettingsSettingsDto {
    setting1: boolean;
    setting2?: string | undefined;
    setting3: Date;
    setting4: string;
    setting5: number;
}

export class BasePaginatedResult implements IBasePaginatedResult {
    pageIndex!: number;
    pageSize!: number;
    totalItems!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IBasePaginatedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.totalItems = _data["totalItems"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): BasePaginatedResult {
        data = typeof data === 'object' ? data : {};
        let result = new BasePaginatedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["totalItems"] = this.totalItems;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }

    clone(): BasePaginatedResult {
        const json = this.toJSON();
        let result = new BasePaginatedResult();
        result.init(json);
        return result;
    }
}

export interface IBasePaginatedResult {
    pageIndex: number;
    pageSize: number;
    totalItems: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class GetApplicationSettingsAuditlogQueryResult extends BasePaginatedResult implements IGetApplicationSettingsAuditlogQueryResult {
    auditlogs?: AuditlogDto[] | undefined;

    constructor(data?: IGetApplicationSettingsAuditlogQueryResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["auditlogs"])) {
                this.auditlogs = [] as any;
                for (let item of _data["auditlogs"])
                    this.auditlogs!.push(AuditlogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetApplicationSettingsAuditlogQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetApplicationSettingsAuditlogQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.auditlogs)) {
            data["auditlogs"] = [];
            for (let item of this.auditlogs)
                data["auditlogs"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): GetApplicationSettingsAuditlogQueryResult {
        const json = this.toJSON();
        let result = new GetApplicationSettingsAuditlogQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetApplicationSettingsAuditlogQueryResult extends IBasePaginatedResult {
    auditlogs?: AuditlogDto[] | undefined;
}

export class AuditlogDto extends EntityDto implements IAuditlogDto {
    modifiedBy?: string | undefined;
    modifiedOn!: Date;
    auditlogItems?: AuditlogItemDto[] | undefined;

    constructor(data?: IAuditlogDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.modifiedBy = _data["modifiedBy"];
            this.modifiedOn = _data["modifiedOn"] ? new Date(_data["modifiedOn"].toString()) : <any>undefined;
            if (Array.isArray(_data["auditlogItems"])) {
                this.auditlogItems = [] as any;
                for (let item of _data["auditlogItems"])
                    this.auditlogItems!.push(AuditlogItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuditlogDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditlogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedOn"] = this.modifiedOn ? this.modifiedOn.toISOString() : <any>undefined;
        if (Array.isArray(this.auditlogItems)) {
            data["auditlogItems"] = [];
            for (let item of this.auditlogItems)
                data["auditlogItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): AuditlogDto {
        const json = this.toJSON();
        let result = new AuditlogDto();
        result.init(json);
        return result;
    }
}

export interface IAuditlogDto extends IEntityDto {
    modifiedBy?: string | undefined;
    modifiedOn: Date;
    auditlogItems?: AuditlogItemDto[] | undefined;
}

export class AuditlogItemDto extends EntityDto implements IAuditlogItemDto {
    propertyName?: string | undefined;
    status!: AuditlogStatusEnum;
    type!: AuditlogTypeEnum;
    currentValueAsString?: string | undefined;
    previousValueAsString?: string | undefined;
    auditlogItems?: AuditlogItemDto[] | undefined;

    constructor(data?: IAuditlogItemDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.status = _data["status"];
            this.type = _data["type"];
            this.currentValueAsString = _data["currentValueAsString"];
            this.previousValueAsString = _data["previousValueAsString"];
            if (Array.isArray(_data["auditlogItems"])) {
                this.auditlogItems = [] as any;
                for (let item of _data["auditlogItems"])
                    this.auditlogItems!.push(AuditlogItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuditlogItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditlogItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["status"] = this.status;
        data["type"] = this.type;
        data["currentValueAsString"] = this.currentValueAsString;
        data["previousValueAsString"] = this.previousValueAsString;
        if (Array.isArray(this.auditlogItems)) {
            data["auditlogItems"] = [];
            for (let item of this.auditlogItems)
                data["auditlogItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): AuditlogItemDto {
        const json = this.toJSON();
        let result = new AuditlogItemDto();
        result.init(json);
        return result;
    }
}

export interface IAuditlogItemDto extends IEntityDto {
    propertyName?: string | undefined;
    status: AuditlogStatusEnum;
    type: AuditlogTypeEnum;
    currentValueAsString?: string | undefined;
    previousValueAsString?: string | undefined;
    auditlogItems?: AuditlogItemDto[] | undefined;
}

export enum AuditlogStatusEnum {
    Unchanged = 0,
    Added = 1,
    Updated = 2,
    Removed = 3,
}

export enum AuditlogTypeEnum {
    None = 0,
    Text = 1,
    Date = 2,
    DateTime = 3,
    Time = 4,
    Currency = 5,
    Decimal = 6,
    Number = 7,
    OnOff = 8,
    YesNo = 9,
}

export class GetUserByIdQueryResult implements IGetUserByIdQueryResult {
    user?: UserDto | undefined;

    constructor(data?: IGetUserByIdQueryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetUserByIdQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserByIdQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetUserByIdQueryResult {
        const json = this.toJSON();
        let result = new GetUserByIdQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetUserByIdQueryResult {
    user?: UserDto | undefined;
}

export class SoftDeleteEntityDto extends AuditableEntityDto implements ISoftDeleteEntityDto {
    deleted!: boolean;
    deletedBy?: string | undefined;
    deletedOn?: Date | undefined;

    constructor(data?: ISoftDeleteEntityDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.deleted = _data["deleted"];
            this.deletedBy = _data["deletedBy"];
            this.deletedOn = _data["deletedOn"] ? new Date(_data["deletedOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SoftDeleteEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new SoftDeleteEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deleted"] = this.deleted;
        data["deletedBy"] = this.deletedBy;
        data["deletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): SoftDeleteEntityDto {
        const json = this.toJSON();
        let result = new SoftDeleteEntityDto();
        result.init(json);
        return result;
    }
}

export interface ISoftDeleteEntityDto extends IAuditableEntityDto {
    deleted: boolean;
    deletedBy?: string | undefined;
    deletedOn?: Date | undefined;
}

export class UserDto extends SoftDeleteEntityDto implements IUserDto {
    externalId?: string | undefined;
    fullname?: string | undefined;
    givenName?: string | undefined;
    familyName?: string | undefined;
    middleName?: string | undefined;
    email?: string | undefined;
    gender?: GenderEnum | undefined;
    birthDate?: Date | undefined;
    zoneInfo?: string | undefined;
    locale?: string | undefined;
    userRoles?: UserRoleDto[] | undefined;

    constructor(data?: IUserDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.externalId = _data["externalId"];
            this.fullname = _data["fullname"];
            this.givenName = _data["givenName"];
            this.familyName = _data["familyName"];
            this.middleName = _data["middleName"];
            this.email = _data["email"];
            this.gender = _data["gender"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.zoneInfo = _data["zoneInfo"];
            this.locale = _data["locale"];
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["externalId"] = this.externalId;
        data["fullname"] = this.fullname;
        data["givenName"] = this.givenName;
        data["familyName"] = this.familyName;
        data["middleName"] = this.middleName;
        data["email"] = this.email;
        data["gender"] = this.gender;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["zoneInfo"] = this.zoneInfo;
        data["locale"] = this.locale;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto extends ISoftDeleteEntityDto {
    externalId?: string | undefined;
    fullname?: string | undefined;
    givenName?: string | undefined;
    familyName?: string | undefined;
    middleName?: string | undefined;
    email?: string | undefined;
    gender?: GenderEnum | undefined;
    birthDate?: Date | undefined;
    zoneInfo?: string | undefined;
    locale?: string | undefined;
    userRoles?: UserRoleDto[] | undefined;
}

export enum GenderEnum {
    Male = 1,
    Female = 2,
}

export class UserRoleDto implements IUserRoleDto {
    roleId!: string;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        return data;
    }

    clone(): UserRoleDto {
        const json = this.toJSON();
        let result = new UserRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUserRoleDto {
    roleId: string;
}

export class GetCurrentUserFeatureFlagsQueryResult implements IGetCurrentUserFeatureFlagsQueryResult {
    featureFlags?: string[] | undefined;

    constructor(data?: IGetCurrentUserFeatureFlagsQueryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["featureFlags"])) {
                this.featureFlags = [] as any;
                for (let item of _data["featureFlags"])
                    this.featureFlags!.push(item);
            }
        }
    }

    static fromJS(data: any): GetCurrentUserFeatureFlagsQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentUserFeatureFlagsQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.featureFlags)) {
            data["featureFlags"] = [];
            for (let item of this.featureFlags)
                data["featureFlags"].push(item);
        }
        return data;
    }

    clone(): GetCurrentUserFeatureFlagsQueryResult {
        const json = this.toJSON();
        let result = new GetCurrentUserFeatureFlagsQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentUserFeatureFlagsQueryResult {
    featureFlags?: string[] | undefined;
}

export class GetCurrentUserFeatureFlagsQuery implements IGetCurrentUserFeatureFlagsQuery {

    constructor(data?: IGetCurrentUserFeatureFlagsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetCurrentUserFeatureFlagsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentUserFeatureFlagsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): GetCurrentUserFeatureFlagsQuery {
        const json = this.toJSON();
        let result = new GetCurrentUserFeatureFlagsQuery();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentUserFeatureFlagsQuery {
}

export class SearchCustomersQueryResult extends BasePaginatedResult implements ISearchCustomersQueryResult {
    customers?: SearchCustomerDto[] | undefined;

    constructor(data?: ISearchCustomersQueryResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["customers"])) {
                this.customers = [] as any;
                for (let item of _data["customers"])
                    this.customers!.push(SearchCustomerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchCustomersQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchCustomersQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customers)) {
            data["customers"] = [];
            for (let item of this.customers)
                data["customers"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): SearchCustomersQueryResult {
        const json = this.toJSON();
        let result = new SearchCustomersQueryResult();
        result.init(json);
        return result;
    }
}

export interface ISearchCustomersQueryResult extends IBasePaginatedResult {
    customers?: SearchCustomerDto[] | undefined;
}

export class SearchCustomerDto implements ISearchCustomerDto {
    id!: string;
    code!: number;
    name?: string | undefined;

    constructor(data?: ISearchCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SearchCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        return data;
    }

    clone(): SearchCustomerDto {
        const json = this.toJSON();
        let result = new SearchCustomerDto();
        result.init(json);
        return result;
    }
}

export interface ISearchCustomerDto {
    id: string;
    code: number;
    name?: string | undefined;
}

export enum SearchCustomersOrderByEnum {
    Code = 0,
    Name = 1,
}

export class GetCustomerByIdQueryResult implements IGetCustomerByIdQueryResult {
    customer?: CustomerDto | undefined;

    constructor(data?: IGetCustomerByIdQueryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customer = _data["customer"] ? CustomerDto.fromJS(_data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCustomerByIdQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerByIdQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetCustomerByIdQueryResult {
        const json = this.toJSON();
        let result = new GetCustomerByIdQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetCustomerByIdQueryResult {
    customer?: CustomerDto | undefined;
}

export class CustomerDto extends SoftDeleteEntityDto implements ICustomerDto {
    code!: number;
    name?: string | undefined;

    constructor(data?: ICustomerDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        super.toJSON(data);
        return data;
    }

    clone(): CustomerDto {
        const json = this.toJSON();
        let result = new CustomerDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerDto extends ISoftDeleteEntityDto {
    code: number;
    name?: string | undefined;
}

export class CreateCustomerResponse implements ICreateCustomerResponse {
    id!: string;

    constructor(data?: ICreateCustomerResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateCustomerResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): CreateCustomerResponse {
        const json = this.toJSON();
        let result = new CreateCustomerResponse();
        result.init(json);
        return result;
    }
}

export interface ICreateCustomerResponse {
    id: string;
}

export class CreateCustomerCommand implements ICreateCustomerCommand {
    name?: string | undefined;

    constructor(data?: ICreateCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }

    clone(): CreateCustomerCommand {
        const json = this.toJSON();
        let result = new CreateCustomerCommand();
        result.init(json);
        return result;
    }
}

export interface ICreateCustomerCommand {
    name?: string | undefined;
}

export class UpdateCustomerCommand implements IUpdateCustomerCommand {
    timestamp?: string | undefined;
    name?: string | undefined;

    constructor(data?: IUpdateCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp;
        data["name"] = this.name;
        return data;
    }

    clone(): UpdateCustomerCommand {
        const json = this.toJSON();
        let result = new UpdateCustomerCommand();
        result.init(json);
        return result;
    }
}

export interface IUpdateCustomerCommand {
    timestamp?: string | undefined;
    name?: string | undefined;
}

export class DeleteCustomerCommand implements IDeleteCustomerCommand {

    constructor(data?: IDeleteCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): DeleteCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): DeleteCustomerCommand {
        const json = this.toJSON();
        let result = new DeleteCustomerCommand();
        result.init(json);
        return result;
    }
}

export interface IDeleteCustomerCommand {
}

export class GetCustomerAuditlogQueryResult extends BasePaginatedResult implements IGetCustomerAuditlogQueryResult {
    customerId!: string;
    auditlogs?: AuditlogDto[] | undefined;

    constructor(data?: IGetCustomerAuditlogQueryResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customerId = _data["customerId"];
            if (Array.isArray(_data["auditlogs"])) {
                this.auditlogs = [] as any;
                for (let item of _data["auditlogs"])
                    this.auditlogs!.push(AuditlogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetCustomerAuditlogQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerAuditlogQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        if (Array.isArray(this.auditlogs)) {
            data["auditlogs"] = [];
            for (let item of this.auditlogs)
                data["auditlogs"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): GetCustomerAuditlogQueryResult {
        const json = this.toJSON();
        let result = new GetCustomerAuditlogQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetCustomerAuditlogQueryResult extends IBasePaginatedResult {
    customerId: string;
    auditlogs?: AuditlogDto[] | undefined;
}

export class CustomerLookupQueryResult extends BasePaginatedResult implements ICustomerLookupQueryResult {
    customers?: CustomerLookupDto[] | undefined;

    constructor(data?: ICustomerLookupQueryResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["customers"])) {
                this.customers = [] as any;
                for (let item of _data["customers"])
                    this.customers!.push(CustomerLookupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerLookupQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerLookupQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customers)) {
            data["customers"] = [];
            for (let item of this.customers)
                data["customers"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): CustomerLookupQueryResult {
        const json = this.toJSON();
        let result = new CustomerLookupQueryResult();
        result.init(json);
        return result;
    }
}

export interface ICustomerLookupQueryResult extends IBasePaginatedResult {
    customers?: CustomerLookupDto[] | undefined;
}

export class CustomerLookupDto implements ICustomerLookupDto {
    id!: string;
    code!: number;
    name?: string | undefined;

    constructor(data?: ICustomerLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CustomerLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        return data;
    }

    clone(): CustomerLookupDto {
        const json = this.toJSON();
        let result = new CustomerLookupDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerLookupDto {
    id: string;
    code: number;
    name?: string | undefined;
}

export enum CustomerLookupOrderByEnum {
    Code = 0,
    Name = 1,
}

export class GetFeatureFlagSettingsQueryResult implements IGetFeatureFlagSettingsQueryResult {
    featureFlagSettings?: FeatureFlagSettingsDto | undefined;

    constructor(data?: IGetFeatureFlagSettingsQueryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.featureFlagSettings = _data["featureFlagSettings"] ? FeatureFlagSettingsDto.fromJS(_data["featureFlagSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetFeatureFlagSettingsQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetFeatureFlagSettingsQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["featureFlagSettings"] = this.featureFlagSettings ? this.featureFlagSettings.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetFeatureFlagSettingsQueryResult {
        const json = this.toJSON();
        let result = new GetFeatureFlagSettingsQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetFeatureFlagSettingsQueryResult {
    featureFlagSettings?: FeatureFlagSettingsDto | undefined;
}

export class FeatureFlagSettingsDto extends AuditableEntityDto implements IFeatureFlagSettingsDto {
    settings?: FeatureFlagSettingsSettingsDto | undefined;

    constructor(data?: IFeatureFlagSettingsDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.settings = _data["settings"] ? FeatureFlagSettingsSettingsDto.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureFlagSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureFlagSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): FeatureFlagSettingsDto {
        const json = this.toJSON();
        let result = new FeatureFlagSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IFeatureFlagSettingsDto extends IAuditableEntityDto {
    settings?: FeatureFlagSettingsSettingsDto | undefined;
}

export class FeatureFlagSettingsSettingsDto implements IFeatureFlagSettingsSettingsDto {
    featureFlags?: FeatureFlagDto[] | undefined;

    constructor(data?: IFeatureFlagSettingsSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["featureFlags"])) {
                this.featureFlags = [] as any;
                for (let item of _data["featureFlags"])
                    this.featureFlags!.push(FeatureFlagDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FeatureFlagSettingsSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureFlagSettingsSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.featureFlags)) {
            data["featureFlags"] = [];
            for (let item of this.featureFlags)
                data["featureFlags"].push(item.toJSON());
        }
        return data;
    }

    clone(): FeatureFlagSettingsSettingsDto {
        const json = this.toJSON();
        let result = new FeatureFlagSettingsSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IFeatureFlagSettingsSettingsDto {
    featureFlags?: FeatureFlagDto[] | undefined;
}

export class FeatureFlagDto extends AuditableEntityDto implements IFeatureFlagDto {
    name?: string | undefined;
    description?: string | undefined;
    enabledForAll!: boolean;
    enabledForUsers?: string[] | undefined;

    constructor(data?: IFeatureFlagDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.enabledForAll = _data["enabledForAll"];
            if (Array.isArray(_data["enabledForUsers"])) {
                this.enabledForUsers = [] as any;
                for (let item of _data["enabledForUsers"])
                    this.enabledForUsers!.push(item);
            }
        }
    }

    static fromJS(data: any): FeatureFlagDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureFlagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["enabledForAll"] = this.enabledForAll;
        if (Array.isArray(this.enabledForUsers)) {
            data["enabledForUsers"] = [];
            for (let item of this.enabledForUsers)
                data["enabledForUsers"].push(item);
        }
        super.toJSON(data);
        return data;
    }

    clone(): FeatureFlagDto {
        const json = this.toJSON();
        let result = new FeatureFlagDto();
        result.init(json);
        return result;
    }
}

export interface IFeatureFlagDto extends IAuditableEntityDto {
    name?: string | undefined;
    description?: string | undefined;
    enabledForAll: boolean;
    enabledForUsers?: string[] | undefined;
}

export class GetFeatureFlagSettingsQuery implements IGetFeatureFlagSettingsQuery {

    constructor(data?: IGetFeatureFlagSettingsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetFeatureFlagSettingsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetFeatureFlagSettingsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): GetFeatureFlagSettingsQuery {
        const json = this.toJSON();
        let result = new GetFeatureFlagSettingsQuery();
        result.init(json);
        return result;
    }
}

export interface IGetFeatureFlagSettingsQuery {
}

export class SaveFeatureFlagSettingsCommand implements ISaveFeatureFlagSettingsCommand {
    timestamp?: string | undefined;
    settings?: SaveFeatureFlagSettingsCommandSettingsDto | undefined;

    constructor(data?: ISaveFeatureFlagSettingsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"];
            this.settings = _data["settings"] ? SaveFeatureFlagSettingsCommandSettingsDto.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SaveFeatureFlagSettingsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SaveFeatureFlagSettingsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp;
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        return data;
    }

    clone(): SaveFeatureFlagSettingsCommand {
        const json = this.toJSON();
        let result = new SaveFeatureFlagSettingsCommand();
        result.init(json);
        return result;
    }
}

export interface ISaveFeatureFlagSettingsCommand {
    timestamp?: string | undefined;
    settings?: SaveFeatureFlagSettingsCommandSettingsDto | undefined;
}

export class SaveFeatureFlagSettingsCommandSettingsDto implements ISaveFeatureFlagSettingsCommandSettingsDto {
    featureFlags?: SaveFeatureFlagSettingsCommandSettingsFeatureFlagDto[] | undefined;

    constructor(data?: ISaveFeatureFlagSettingsCommandSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["featureFlags"])) {
                this.featureFlags = [] as any;
                for (let item of _data["featureFlags"])
                    this.featureFlags!.push(SaveFeatureFlagSettingsCommandSettingsFeatureFlagDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SaveFeatureFlagSettingsCommandSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveFeatureFlagSettingsCommandSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.featureFlags)) {
            data["featureFlags"] = [];
            for (let item of this.featureFlags)
                data["featureFlags"].push(item.toJSON());
        }
        return data;
    }

    clone(): SaveFeatureFlagSettingsCommandSettingsDto {
        const json = this.toJSON();
        let result = new SaveFeatureFlagSettingsCommandSettingsDto();
        result.init(json);
        return result;
    }
}

export interface ISaveFeatureFlagSettingsCommandSettingsDto {
    featureFlags?: SaveFeatureFlagSettingsCommandSettingsFeatureFlagDto[] | undefined;
}

export class SaveFeatureFlagSettingsCommandSettingsFeatureFlagDto implements ISaveFeatureFlagSettingsCommandSettingsFeatureFlagDto {
    id!: string;
    name?: string | undefined;
    description?: string | undefined;
    enabledForAll!: boolean;
    enabledForUsers?: string[] | undefined;

    constructor(data?: ISaveFeatureFlagSettingsCommandSettingsFeatureFlagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.enabledForAll = _data["enabledForAll"];
            if (Array.isArray(_data["enabledForUsers"])) {
                this.enabledForUsers = [] as any;
                for (let item of _data["enabledForUsers"])
                    this.enabledForUsers!.push(item);
            }
        }
    }

    static fromJS(data: any): SaveFeatureFlagSettingsCommandSettingsFeatureFlagDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveFeatureFlagSettingsCommandSettingsFeatureFlagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["enabledForAll"] = this.enabledForAll;
        if (Array.isArray(this.enabledForUsers)) {
            data["enabledForUsers"] = [];
            for (let item of this.enabledForUsers)
                data["enabledForUsers"].push(item);
        }
        return data;
    }

    clone(): SaveFeatureFlagSettingsCommandSettingsFeatureFlagDto {
        const json = this.toJSON();
        let result = new SaveFeatureFlagSettingsCommandSettingsFeatureFlagDto();
        result.init(json);
        return result;
    }
}

export interface ISaveFeatureFlagSettingsCommandSettingsFeatureFlagDto {
    id: string;
    name?: string | undefined;
    description?: string | undefined;
    enabledForAll: boolean;
    enabledForUsers?: string[] | undefined;
}

export class GetFeatureFlagSettingsAuditlogQueryResult extends BasePaginatedResult implements IGetFeatureFlagSettingsAuditlogQueryResult {
    auditlogs?: AuditlogDto[] | undefined;

    constructor(data?: IGetFeatureFlagSettingsAuditlogQueryResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["auditlogs"])) {
                this.auditlogs = [] as any;
                for (let item of _data["auditlogs"])
                    this.auditlogs!.push(AuditlogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetFeatureFlagSettingsAuditlogQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetFeatureFlagSettingsAuditlogQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.auditlogs)) {
            data["auditlogs"] = [];
            for (let item of this.auditlogs)
                data["auditlogs"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): GetFeatureFlagSettingsAuditlogQueryResult {
        const json = this.toJSON();
        let result = new GetFeatureFlagSettingsAuditlogQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetFeatureFlagSettingsAuditlogQueryResult extends IBasePaginatedResult {
    auditlogs?: AuditlogDto[] | undefined;
}

export class SearchInvoicesQueryResult extends BasePaginatedResult implements ISearchInvoicesQueryResult {
    invoices?: SearchInvoiceDto[] | undefined;

    constructor(data?: ISearchInvoicesQueryResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["invoices"])) {
                this.invoices = [] as any;
                for (let item of _data["invoices"])
                    this.invoices!.push(SearchInvoiceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchInvoicesQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchInvoicesQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.invoices)) {
            data["invoices"] = [];
            for (let item of this.invoices)
                data["invoices"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): SearchInvoicesQueryResult {
        const json = this.toJSON();
        let result = new SearchInvoicesQueryResult();
        result.init(json);
        return result;
    }
}

export interface ISearchInvoicesQueryResult extends IBasePaginatedResult {
    invoices?: SearchInvoiceDto[] | undefined;
}

export class SearchInvoiceDto extends SoftDeleteEntityDto implements ISearchInvoiceDto {
    invoiceNumber?: string | undefined;
    customerId!: string;
    customerName?: string | undefined;
    invoiceDate!: Date;
    paymentTerm!: number;
    orderReference?: string | undefined;
    status!: InvoiceStatusEnum;

    constructor(data?: ISearchInvoiceDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.invoiceNumber = _data["invoiceNumber"];
            this.customerId = _data["customerId"];
            this.customerName = _data["customerName"];
            this.invoiceDate = _data["invoiceDate"] ? new Date(_data["invoiceDate"].toString()) : <any>undefined;
            this.paymentTerm = _data["paymentTerm"];
            this.orderReference = _data["orderReference"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): SearchInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceNumber"] = this.invoiceNumber;
        data["customerId"] = this.customerId;
        data["customerName"] = this.customerName;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["paymentTerm"] = this.paymentTerm;
        data["orderReference"] = this.orderReference;
        data["status"] = this.status;
        super.toJSON(data);
        return data;
    }

    clone(): SearchInvoiceDto {
        const json = this.toJSON();
        let result = new SearchInvoiceDto();
        result.init(json);
        return result;
    }
}

export interface ISearchInvoiceDto extends ISoftDeleteEntityDto {
    invoiceNumber?: string | undefined;
    customerId: string;
    customerName?: string | undefined;
    invoiceDate: Date;
    paymentTerm: number;
    orderReference?: string | undefined;
    status: InvoiceStatusEnum;
}

export enum InvoiceStatusEnum {
    Draft = 0,
    Sent = 1,
    Paid = 2,
    Cancelled = 3,
}

export enum SearchInvoicesOrderByEnum {
    InvoiceNumber = 0,
    InvoiceDate = 1,
}

export class GetInvoiceByIdQueryResult implements IGetInvoiceByIdQueryResult {
    invoice?: InvoiceDto | undefined;

    constructor(data?: IGetInvoiceByIdQueryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoice = _data["invoice"] ? InvoiceDto.fromJS(_data["invoice"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetInvoiceByIdQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetInvoiceByIdQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetInvoiceByIdQueryResult {
        const json = this.toJSON();
        let result = new GetInvoiceByIdQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetInvoiceByIdQueryResult {
    invoice?: InvoiceDto | undefined;
}

export class InvoiceDto extends SoftDeleteEntityDto implements IInvoiceDto {
    invoiceNumber?: string | undefined;
    customerId!: string;
    invoiceDate!: Date;
    paymentTerm!: number;
    orderReference?: string | undefined;
    status!: InvoiceStatusEnum;
    pdfIsSynced!: boolean;
    pdfDataChecksum?: string | undefined;
    invoiceLines?: InvoiceLineDto[] | undefined;

    constructor(data?: IInvoiceDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.invoiceNumber = _data["invoiceNumber"];
            this.customerId = _data["customerId"];
            this.invoiceDate = _data["invoiceDate"] ? new Date(_data["invoiceDate"].toString()) : <any>undefined;
            this.paymentTerm = _data["paymentTerm"];
            this.orderReference = _data["orderReference"];
            this.status = _data["status"];
            this.pdfIsSynced = _data["pdfIsSynced"];
            this.pdfDataChecksum = _data["pdfDataChecksum"];
            if (Array.isArray(_data["invoiceLines"])) {
                this.invoiceLines = [] as any;
                for (let item of _data["invoiceLines"])
                    this.invoiceLines!.push(InvoiceLineDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceNumber"] = this.invoiceNumber;
        data["customerId"] = this.customerId;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["paymentTerm"] = this.paymentTerm;
        data["orderReference"] = this.orderReference;
        data["status"] = this.status;
        data["pdfIsSynced"] = this.pdfIsSynced;
        data["pdfDataChecksum"] = this.pdfDataChecksum;
        if (Array.isArray(this.invoiceLines)) {
            data["invoiceLines"] = [];
            for (let item of this.invoiceLines)
                data["invoiceLines"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): InvoiceDto {
        const json = this.toJSON();
        let result = new InvoiceDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDto extends ISoftDeleteEntityDto {
    invoiceNumber?: string | undefined;
    customerId: string;
    invoiceDate: Date;
    paymentTerm: number;
    orderReference?: string | undefined;
    status: InvoiceStatusEnum;
    pdfIsSynced: boolean;
    pdfDataChecksum?: string | undefined;
    invoiceLines?: InvoiceLineDto[] | undefined;
}

export class InvoiceLineDto extends EntityDto implements IInvoiceLineDto {
    lineNumber!: number;
    quantity!: number;
    description?: string | undefined;
    sellingPrice!: number;

    constructor(data?: IInvoiceLineDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.lineNumber = _data["lineNumber"];
            this.quantity = _data["quantity"];
            this.description = _data["description"];
            this.sellingPrice = _data["sellingPrice"];
        }
    }

    static fromJS(data: any): InvoiceLineDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceLineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lineNumber"] = this.lineNumber;
        data["quantity"] = this.quantity;
        data["description"] = this.description;
        data["sellingPrice"] = this.sellingPrice;
        super.toJSON(data);
        return data;
    }

    clone(): InvoiceLineDto {
        const json = this.toJSON();
        let result = new InvoiceLineDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceLineDto extends IEntityDto {
    lineNumber: number;
    quantity: number;
    description?: string | undefined;
    sellingPrice: number;
}

export class CreateInvoiceResponse implements ICreateInvoiceResponse {
    id!: string;

    constructor(data?: ICreateInvoiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateInvoiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): CreateInvoiceResponse {
        const json = this.toJSON();
        let result = new CreateInvoiceResponse();
        result.init(json);
        return result;
    }
}

export interface ICreateInvoiceResponse {
    id: string;
}

export class CreateInvoiceCommand implements ICreateInvoiceCommand {
    customerId!: string;
    invoiceDate!: Date;
    paymentTerm!: number;
    orderReference?: string | undefined;
    invoiceLines?: CreateInvoiceCommandInvoiceLine[] | undefined;

    constructor(data?: ICreateInvoiceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"];
            this.invoiceDate = _data["invoiceDate"] ? new Date(_data["invoiceDate"].toString()) : <any>undefined;
            this.paymentTerm = _data["paymentTerm"];
            this.orderReference = _data["orderReference"];
            if (Array.isArray(_data["invoiceLines"])) {
                this.invoiceLines = [] as any;
                for (let item of _data["invoiceLines"])
                    this.invoiceLines!.push(CreateInvoiceCommandInvoiceLine.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateInvoiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["paymentTerm"] = this.paymentTerm;
        data["orderReference"] = this.orderReference;
        if (Array.isArray(this.invoiceLines)) {
            data["invoiceLines"] = [];
            for (let item of this.invoiceLines)
                data["invoiceLines"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateInvoiceCommand {
        const json = this.toJSON();
        let result = new CreateInvoiceCommand();
        result.init(json);
        return result;
    }
}

export interface ICreateInvoiceCommand {
    customerId: string;
    invoiceDate: Date;
    paymentTerm: number;
    orderReference?: string | undefined;
    invoiceLines?: CreateInvoiceCommandInvoiceLine[] | undefined;
}

export class CreateInvoiceCommandInvoiceLine implements ICreateInvoiceCommandInvoiceLine {
    quantity!: number;
    description?: string | undefined;
    sellingPrice!: number;

    constructor(data?: ICreateInvoiceCommandInvoiceLine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quantity = _data["quantity"];
            this.description = _data["description"];
            this.sellingPrice = _data["sellingPrice"];
        }
    }

    static fromJS(data: any): CreateInvoiceCommandInvoiceLine {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceCommandInvoiceLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        data["description"] = this.description;
        data["sellingPrice"] = this.sellingPrice;
        return data;
    }

    clone(): CreateInvoiceCommandInvoiceLine {
        const json = this.toJSON();
        let result = new CreateInvoiceCommandInvoiceLine();
        result.init(json);
        return result;
    }
}

export interface ICreateInvoiceCommandInvoiceLine {
    quantity: number;
    description?: string | undefined;
    sellingPrice: number;
}

export class UpdateInvoiceCommand implements IUpdateInvoiceCommand {
    timestamp?: string | undefined;
    customerId!: string;
    invoiceDate!: Date;
    paymentTerm!: number;
    orderReference?: string | undefined;
    invoiceLines?: UpdateInvoiceCommandInvoiceLineDto[] | undefined;

    constructor(data?: IUpdateInvoiceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"];
            this.customerId = _data["customerId"];
            this.invoiceDate = _data["invoiceDate"] ? new Date(_data["invoiceDate"].toString()) : <any>undefined;
            this.paymentTerm = _data["paymentTerm"];
            this.orderReference = _data["orderReference"];
            if (Array.isArray(_data["invoiceLines"])) {
                this.invoiceLines = [] as any;
                for (let item of _data["invoiceLines"])
                    this.invoiceLines!.push(UpdateInvoiceCommandInvoiceLineDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateInvoiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInvoiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp;
        data["customerId"] = this.customerId;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["paymentTerm"] = this.paymentTerm;
        data["orderReference"] = this.orderReference;
        if (Array.isArray(this.invoiceLines)) {
            data["invoiceLines"] = [];
            for (let item of this.invoiceLines)
                data["invoiceLines"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpdateInvoiceCommand {
        const json = this.toJSON();
        let result = new UpdateInvoiceCommand();
        result.init(json);
        return result;
    }
}

export interface IUpdateInvoiceCommand {
    timestamp?: string | undefined;
    customerId: string;
    invoiceDate: Date;
    paymentTerm: number;
    orderReference?: string | undefined;
    invoiceLines?: UpdateInvoiceCommandInvoiceLineDto[] | undefined;
}

export class UpdateInvoiceCommandInvoiceLineDto implements IUpdateInvoiceCommandInvoiceLineDto {
    quantity!: number;
    description?: string | undefined;
    sellingPrice!: number;
    id?: string | undefined;

    constructor(data?: IUpdateInvoiceCommandInvoiceLineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quantity = _data["quantity"];
            this.description = _data["description"];
            this.sellingPrice = _data["sellingPrice"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateInvoiceCommandInvoiceLineDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInvoiceCommandInvoiceLineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        data["description"] = this.description;
        data["sellingPrice"] = this.sellingPrice;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateInvoiceCommandInvoiceLineDto {
        const json = this.toJSON();
        let result = new UpdateInvoiceCommandInvoiceLineDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateInvoiceCommandInvoiceLineDto {
    quantity: number;
    description?: string | undefined;
    sellingPrice: number;
    id?: string | undefined;
}

export class DeleteInvoiceCommand implements IDeleteInvoiceCommand {

    constructor(data?: IDeleteInvoiceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): DeleteInvoiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteInvoiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): DeleteInvoiceCommand {
        const json = this.toJSON();
        let result = new DeleteInvoiceCommand();
        result.init(json);
        return result;
    }
}

export interface IDeleteInvoiceCommand {
}

export class MarkInvoiceAsSentCommand implements IMarkInvoiceAsSentCommand {

    constructor(data?: IMarkInvoiceAsSentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): MarkInvoiceAsSentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MarkInvoiceAsSentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): MarkInvoiceAsSentCommand {
        const json = this.toJSON();
        let result = new MarkInvoiceAsSentCommand();
        result.init(json);
        return result;
    }
}

export interface IMarkInvoiceAsSentCommand {
}

export class MarkInvoiceAsPaidCommand implements IMarkInvoiceAsPaidCommand {

    constructor(data?: IMarkInvoiceAsPaidCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): MarkInvoiceAsPaidCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MarkInvoiceAsPaidCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): MarkInvoiceAsPaidCommand {
        const json = this.toJSON();
        let result = new MarkInvoiceAsPaidCommand();
        result.init(json);
        return result;
    }
}

export interface IMarkInvoiceAsPaidCommand {
}

export class MarkInvoiceAsCancelledCommand implements IMarkInvoiceAsCancelledCommand {

    constructor(data?: IMarkInvoiceAsCancelledCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): MarkInvoiceAsCancelledCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MarkInvoiceAsCancelledCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): MarkInvoiceAsCancelledCommand {
        const json = this.toJSON();
        let result = new MarkInvoiceAsCancelledCommand();
        result.init(json);
        return result;
    }
}

export interface IMarkInvoiceAsCancelledCommand {
}

export class GetInvoiceAuditlogQueryResult extends BasePaginatedResult implements IGetInvoiceAuditlogQueryResult {
    invoiceId!: string;
    auditlogs?: AuditlogDto[] | undefined;

    constructor(data?: IGetInvoiceAuditlogQueryResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.invoiceId = _data["invoiceId"];
            if (Array.isArray(_data["auditlogs"])) {
                this.auditlogs = [] as any;
                for (let item of _data["auditlogs"])
                    this.auditlogs!.push(AuditlogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetInvoiceAuditlogQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetInvoiceAuditlogQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceId"] = this.invoiceId;
        if (Array.isArray(this.auditlogs)) {
            data["auditlogs"] = [];
            for (let item of this.auditlogs)
                data["auditlogs"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): GetInvoiceAuditlogQueryResult {
        const json = this.toJSON();
        let result = new GetInvoiceAuditlogQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetInvoiceAuditlogQueryResult extends IBasePaginatedResult {
    invoiceId: string;
    auditlogs?: AuditlogDto[] | undefined;
}

export class CopyInvoiceResponse implements ICopyInvoiceResponse {
    id!: string;

    constructor(data?: ICopyInvoiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CopyInvoiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CopyInvoiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): CopyInvoiceResponse {
        const json = this.toJSON();
        let result = new CopyInvoiceResponse();
        result.init(json);
        return result;
    }
}

export interface ICopyInvoiceResponse {
    id: string;
}

export class CopyInvoiceCommand implements ICopyInvoiceCommand {

    constructor(data?: ICopyInvoiceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CopyInvoiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CopyInvoiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): CopyInvoiceCommand {
        const json = this.toJSON();
        let result = new CopyInvoiceCommand();
        result.init(json);
        return result;
    }
}

export interface ICopyInvoiceCommand {
}

export class CreditInvoiceResponse implements ICreditInvoiceResponse {
    id!: string;

    constructor(data?: ICreditInvoiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreditInvoiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreditInvoiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): CreditInvoiceResponse {
        const json = this.toJSON();
        let result = new CreditInvoiceResponse();
        result.init(json);
        return result;
    }
}

export interface ICreditInvoiceResponse {
    id: string;
}

export class CreditInvoiceCommand implements ICreditInvoiceCommand {

    constructor(data?: ICreditInvoiceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CreditInvoiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreditInvoiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): CreditInvoiceCommand {
        const json = this.toJSON();
        let result = new CreditInvoiceCommand();
        result.init(json);
        return result;
    }
}

export interface ICreditInvoiceCommand {
}

export class InvoiceLookupQueryResult extends BasePaginatedResult implements IInvoiceLookupQueryResult {
    invoices?: InvoiceLookupDto[] | undefined;

    constructor(data?: IInvoiceLookupQueryResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["invoices"])) {
                this.invoices = [] as any;
                for (let item of _data["invoices"])
                    this.invoices!.push(InvoiceLookupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvoiceLookupQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceLookupQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.invoices)) {
            data["invoices"] = [];
            for (let item of this.invoices)
                data["invoices"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): InvoiceLookupQueryResult {
        const json = this.toJSON();
        let result = new InvoiceLookupQueryResult();
        result.init(json);
        return result;
    }
}

export interface IInvoiceLookupQueryResult extends IBasePaginatedResult {
    invoices?: InvoiceLookupDto[] | undefined;
}

export class InvoiceLookupDto implements IInvoiceLookupDto {
    id!: string;
    invoiceNumber?: string | undefined;
    customerId!: string;

    constructor(data?: IInvoiceLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): InvoiceLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invoiceNumber"] = this.invoiceNumber;
        data["customerId"] = this.customerId;
        return data;
    }

    clone(): InvoiceLookupDto {
        const json = this.toJSON();
        let result = new InvoiceLookupDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceLookupDto {
    id: string;
    invoiceNumber?: string | undefined;
    customerId: string;
}

export enum InvoiceLookupOrderByEnum {
    InvoiceNumber = 0,
    InvoiceDate = 1,
}

export class LogMessage implements ILogMessage {
    logLevel!: LogLevel;
    eventId!: number;
    message?: string | undefined;
    exceptionMessage?: string | undefined;

    constructor(data?: ILogMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.logLevel = _data["logLevel"];
            this.eventId = _data["eventId"];
            this.message = _data["message"];
            this.exceptionMessage = _data["exceptionMessage"];
        }
    }

    static fromJS(data: any): LogMessage {
        data = typeof data === 'object' ? data : {};
        let result = new LogMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["logLevel"] = this.logLevel;
        data["eventId"] = this.eventId;
        data["message"] = this.message;
        data["exceptionMessage"] = this.exceptionMessage;
        return data;
    }

    clone(): LogMessage {
        const json = this.toJSON();
        let result = new LogMessage();
        result.init(json);
        return result;
    }
}

export interface ILogMessage {
    logLevel: LogLevel;
    eventId: number;
    message?: string | undefined;
    exceptionMessage?: string | undefined;
}

/** Defines logging severity levels. */
export enum LogLevel {
    Trace = 0,
    Debug = 1,
    Information = 2,
    Warning = 3,
    Error = 4,
    Critical = 5,
    None = 6,
}

export class SearchRolesQueryResult extends BasePaginatedResult implements ISearchRolesQueryResult {
    roles?: SearchRoleDto[] | undefined;

    constructor(data?: ISearchRolesQueryResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(SearchRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchRolesQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchRolesQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): SearchRolesQueryResult {
        const json = this.toJSON();
        let result = new SearchRolesQueryResult();
        result.init(json);
        return result;
    }
}

export interface ISearchRolesQueryResult extends IBasePaginatedResult {
    roles?: SearchRoleDto[] | undefined;
}

export class SearchRoleDto extends SoftDeleteEntityDto implements ISearchRoleDto {
    name?: string | undefined;
    externalId?: string | undefined;

    constructor(data?: ISearchRoleDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.externalId = _data["externalId"];
        }
    }

    static fromJS(data: any): SearchRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["externalId"] = this.externalId;
        super.toJSON(data);
        return data;
    }

    clone(): SearchRoleDto {
        const json = this.toJSON();
        let result = new SearchRoleDto();
        result.init(json);
        return result;
    }
}

export interface ISearchRoleDto extends ISoftDeleteEntityDto {
    name?: string | undefined;
    externalId?: string | undefined;
}

export enum SearchRoleOrderByEnum {
    Name = 0,
}

export class GetRoleByIdQueryResult implements IGetRoleByIdQueryResult {
    role?: RoleDto | undefined;

    constructor(data?: IGetRoleByIdQueryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleDto.fromJS(_data["role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRoleByIdQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleByIdQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetRoleByIdQueryResult {
        const json = this.toJSON();
        let result = new GetRoleByIdQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetRoleByIdQueryResult {
    role?: RoleDto | undefined;
}

export class RoleDto extends SoftDeleteEntityDto implements IRoleDto {
    name?: string | undefined;
    externalId?: string | undefined;

    constructor(data?: IRoleDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.externalId = _data["externalId"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["externalId"] = this.externalId;
        super.toJSON(data);
        return data;
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto extends ISoftDeleteEntityDto {
    name?: string | undefined;
    externalId?: string | undefined;
}

export class CreateRoleResponse implements ICreateRoleResponse {
    id!: string;

    constructor(data?: ICreateRoleResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateRoleResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): CreateRoleResponse {
        const json = this.toJSON();
        let result = new CreateRoleResponse();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleResponse {
    id: string;
}

export class CreateRoleCommand implements ICreateRoleCommand {
    name?: string | undefined;
    externalId?: string | undefined;

    constructor(data?: ICreateRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.externalId = _data["externalId"];
        }
    }

    static fromJS(data: any): CreateRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["externalId"] = this.externalId;
        return data;
    }

    clone(): CreateRoleCommand {
        const json = this.toJSON();
        let result = new CreateRoleCommand();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleCommand {
    name?: string | undefined;
    externalId?: string | undefined;
}

export class UpdateRoleCommand implements IUpdateRoleCommand {
    name?: string | undefined;
    externalId?: string | undefined;

    constructor(data?: IUpdateRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.externalId = _data["externalId"];
        }
    }

    static fromJS(data: any): UpdateRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["externalId"] = this.externalId;
        return data;
    }

    clone(): UpdateRoleCommand {
        const json = this.toJSON();
        let result = new UpdateRoleCommand();
        result.init(json);
        return result;
    }
}

export interface IUpdateRoleCommand {
    name?: string | undefined;
    externalId?: string | undefined;
}

export class DeleteRoleCommand implements IDeleteRoleCommand {

    constructor(data?: IDeleteRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): DeleteRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): DeleteRoleCommand {
        const json = this.toJSON();
        let result = new DeleteRoleCommand();
        result.init(json);
        return result;
    }
}

export interface IDeleteRoleCommand {
}

export class GetRoleAuditlogQueryResult extends BasePaginatedResult implements IGetRoleAuditlogQueryResult {
    roleId!: string;
    auditlogs?: AuditlogDto[] | undefined;

    constructor(data?: IGetRoleAuditlogQueryResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.roleId = _data["roleId"];
            if (Array.isArray(_data["auditlogs"])) {
                this.auditlogs = [] as any;
                for (let item of _data["auditlogs"])
                    this.auditlogs!.push(AuditlogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRoleAuditlogQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleAuditlogQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        if (Array.isArray(this.auditlogs)) {
            data["auditlogs"] = [];
            for (let item of this.auditlogs)
                data["auditlogs"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): GetRoleAuditlogQueryResult {
        const json = this.toJSON();
        let result = new GetRoleAuditlogQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetRoleAuditlogQueryResult extends IBasePaginatedResult {
    roleId: string;
    auditlogs?: AuditlogDto[] | undefined;
}

export class RoleLookupQueryResult extends BasePaginatedResult implements IRoleLookupQueryResult {
    roles?: RoleLookupDto[] | undefined;

    constructor(data?: IRoleLookupQueryResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(RoleLookupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleLookupQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new RoleLookupQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): RoleLookupQueryResult {
        const json = this.toJSON();
        let result = new RoleLookupQueryResult();
        result.init(json);
        return result;
    }
}

export interface IRoleLookupQueryResult extends IBasePaginatedResult {
    roles?: RoleLookupDto[] | undefined;
}

export class RoleLookupDto implements IRoleLookupDto {
    id!: string;
    name?: string | undefined;

    constructor(data?: IRoleLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RoleLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): RoleLookupDto {
        const json = this.toJSON();
        let result = new RoleLookupDto();
        result.init(json);
        return result;
    }
}

export interface IRoleLookupDto {
    id: string;
    name?: string | undefined;
}

export enum RoleLookupOrderByEnum {
    Name = 0,
}

export class GetUserPreferencesQueryResult implements IGetUserPreferencesQueryResult {
    userPreferences?: UserPreferencesDto | undefined;

    constructor(data?: IGetUserPreferencesQueryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userPreferences = _data["userPreferences"] ? UserPreferencesDto.fromJS(_data["userPreferences"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetUserPreferencesQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPreferencesQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userPreferences"] = this.userPreferences ? this.userPreferences.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetUserPreferencesQueryResult {
        const json = this.toJSON();
        let result = new GetUserPreferencesQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetUserPreferencesQueryResult {
    userPreferences?: UserPreferencesDto | undefined;
}

export class UserPreferencesDto extends AuditableEntityDto implements IUserPreferencesDto {
    preferences?: UserPreferencesPreferencesDto | undefined;

    constructor(data?: IUserPreferencesDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.preferences = _data["preferences"] ? UserPreferencesPreferencesDto.fromJS(_data["preferences"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserPreferencesDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserPreferencesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preferences"] = this.preferences ? this.preferences.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }

    clone(): UserPreferencesDto {
        const json = this.toJSON();
        let result = new UserPreferencesDto();
        result.init(json);
        return result;
    }
}

export interface IUserPreferencesDto extends IAuditableEntityDto {
    preferences?: UserPreferencesPreferencesDto | undefined;
}

export class UserPreferencesPreferencesDto implements IUserPreferencesPreferencesDto {
    setting1!: boolean;
    setting2?: string | undefined;
    setting3!: Date;
    setting4!: string;
    setting5!: number;

    constructor(data?: IUserPreferencesPreferencesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setting1 = _data["setting1"];
            this.setting2 = _data["setting2"];
            this.setting3 = _data["setting3"] ? new Date(_data["setting3"].toString()) : <any>undefined;
            this.setting4 = _data["setting4"];
            this.setting5 = _data["setting5"];
        }
    }

    static fromJS(data: any): UserPreferencesPreferencesDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserPreferencesPreferencesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting1"] = this.setting1;
        data["setting2"] = this.setting2;
        data["setting3"] = this.setting3 ? this.setting3.toISOString() : <any>undefined;
        data["setting4"] = this.setting4;
        data["setting5"] = this.setting5;
        return data;
    }

    clone(): UserPreferencesPreferencesDto {
        const json = this.toJSON();
        let result = new UserPreferencesPreferencesDto();
        result.init(json);
        return result;
    }
}

export interface IUserPreferencesPreferencesDto {
    setting1: boolean;
    setting2?: string | undefined;
    setting3: Date;
    setting4: string;
    setting5: number;
}

export class GetUserPreferencesQuery implements IGetUserPreferencesQuery {

    constructor(data?: IGetUserPreferencesQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetUserPreferencesQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPreferencesQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): GetUserPreferencesQuery {
        const json = this.toJSON();
        let result = new GetUserPreferencesQuery();
        result.init(json);
        return result;
    }
}

export interface IGetUserPreferencesQuery {
}

export class SaveUserPreferencesCommand implements ISaveUserPreferencesCommand {
    timestamp?: string | undefined;
    preferences?: SaveUserPreferencesPreferencesDto | undefined;

    constructor(data?: ISaveUserPreferencesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"];
            this.preferences = _data["preferences"] ? SaveUserPreferencesPreferencesDto.fromJS(_data["preferences"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SaveUserPreferencesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SaveUserPreferencesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp;
        data["preferences"] = this.preferences ? this.preferences.toJSON() : <any>undefined;
        return data;
    }

    clone(): SaveUserPreferencesCommand {
        const json = this.toJSON();
        let result = new SaveUserPreferencesCommand();
        result.init(json);
        return result;
    }
}

export interface ISaveUserPreferencesCommand {
    timestamp?: string | undefined;
    preferences?: SaveUserPreferencesPreferencesDto | undefined;
}

export class SaveUserPreferencesPreferencesDto implements ISaveUserPreferencesPreferencesDto {
    setting1!: boolean;
    setting2?: string | undefined;
    setting3!: Date;
    setting4!: string;
    setting5!: number;

    constructor(data?: ISaveUserPreferencesPreferencesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setting1 = _data["setting1"];
            this.setting2 = _data["setting2"];
            this.setting3 = _data["setting3"] ? new Date(_data["setting3"].toString()) : <any>undefined;
            this.setting4 = _data["setting4"];
            this.setting5 = _data["setting5"];
        }
    }

    static fromJS(data: any): SaveUserPreferencesPreferencesDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveUserPreferencesPreferencesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting1"] = this.setting1;
        data["setting2"] = this.setting2;
        data["setting3"] = this.setting3 ? this.setting3.toISOString() : <any>undefined;
        data["setting4"] = this.setting4;
        data["setting5"] = this.setting5;
        return data;
    }

    clone(): SaveUserPreferencesPreferencesDto {
        const json = this.toJSON();
        let result = new SaveUserPreferencesPreferencesDto();
        result.init(json);
        return result;
    }
}

export interface ISaveUserPreferencesPreferencesDto {
    setting1: boolean;
    setting2?: string | undefined;
    setting3: Date;
    setting4: string;
    setting5: number;
}

export class GetUserPreferencesAuditlogQueryResult extends BasePaginatedResult implements IGetUserPreferencesAuditlogQueryResult {
    auditlogs?: AuditlogDto[] | undefined;

    constructor(data?: IGetUserPreferencesAuditlogQueryResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["auditlogs"])) {
                this.auditlogs = [] as any;
                for (let item of _data["auditlogs"])
                    this.auditlogs!.push(AuditlogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserPreferencesAuditlogQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPreferencesAuditlogQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.auditlogs)) {
            data["auditlogs"] = [];
            for (let item of this.auditlogs)
                data["auditlogs"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): GetUserPreferencesAuditlogQueryResult {
        const json = this.toJSON();
        let result = new GetUserPreferencesAuditlogQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetUserPreferencesAuditlogQueryResult extends IBasePaginatedResult {
    auditlogs?: AuditlogDto[] | undefined;
}

export class SearchUsersQueryResult extends BasePaginatedResult implements ISearchUsersQueryResult {
    users?: SearchUserDto[] | undefined;

    constructor(data?: ISearchUsersQueryResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(SearchUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchUsersQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchUsersQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): SearchUsersQueryResult {
        const json = this.toJSON();
        let result = new SearchUsersQueryResult();
        result.init(json);
        return result;
    }
}

export interface ISearchUsersQueryResult extends IBasePaginatedResult {
    users?: SearchUserDto[] | undefined;
}

export class SearchUserDto extends SoftDeleteEntityDto implements ISearchUserDto {
    fullname?: string | undefined;
    email?: string | undefined;

    constructor(data?: ISearchUserDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fullname = _data["fullname"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): SearchUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullname"] = this.fullname;
        data["email"] = this.email;
        super.toJSON(data);
        return data;
    }

    clone(): SearchUserDto {
        const json = this.toJSON();
        let result = new SearchUserDto();
        result.init(json);
        return result;
    }
}

export interface ISearchUserDto extends ISoftDeleteEntityDto {
    fullname?: string | undefined;
    email?: string | undefined;
}

export enum SearchUserOrderByEnum {
    FamilyName = 0,
    Fullname = 1,
    Email = 2,
}

export class CreateUserResponse implements ICreateUserResponse {
    id!: string;

    constructor(data?: ICreateUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): CreateUserResponse {
        const json = this.toJSON();
        let result = new CreateUserResponse();
        result.init(json);
        return result;
    }
}

export interface ICreateUserResponse {
    id: string;
}

export class CreateUserCommand implements ICreateUserCommand {
    givenName?: string | undefined;
    familyName?: string | undefined;
    middleName?: string | undefined;
    email?: string | undefined;
    gender?: GenderEnum | undefined;
    birthDate?: Date | undefined;
    zoneInfo?: string | undefined;
    locale?: string | undefined;
    userRoles?: CreateUserCommandUserRole[] | undefined;

    constructor(data?: ICreateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.givenName = _data["givenName"];
            this.familyName = _data["familyName"];
            this.middleName = _data["middleName"];
            this.email = _data["email"];
            this.gender = _data["gender"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.zoneInfo = _data["zoneInfo"];
            this.locale = _data["locale"];
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(CreateUserCommandUserRole.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["givenName"] = this.givenName;
        data["familyName"] = this.familyName;
        data["middleName"] = this.middleName;
        data["email"] = this.email;
        data["gender"] = this.gender;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["zoneInfo"] = this.zoneInfo;
        data["locale"] = this.locale;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateUserCommand {
        const json = this.toJSON();
        let result = new CreateUserCommand();
        result.init(json);
        return result;
    }
}

export interface ICreateUserCommand {
    givenName?: string | undefined;
    familyName?: string | undefined;
    middleName?: string | undefined;
    email?: string | undefined;
    gender?: GenderEnum | undefined;
    birthDate?: Date | undefined;
    zoneInfo?: string | undefined;
    locale?: string | undefined;
    userRoles?: CreateUserCommandUserRole[] | undefined;
}

export class CreateUserCommandUserRole implements ICreateUserCommandUserRole {
    roleId!: string;

    constructor(data?: ICreateUserCommandUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): CreateUserCommandUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommandUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        return data;
    }

    clone(): CreateUserCommandUserRole {
        const json = this.toJSON();
        let result = new CreateUserCommandUserRole();
        result.init(json);
        return result;
    }
}

export interface ICreateUserCommandUserRole {
    roleId: string;
}

export class UpdateUserCommand implements IUpdateUserCommand {
    givenName?: string | undefined;
    familyName?: string | undefined;
    middleName?: string | undefined;
    email?: string | undefined;
    gender?: GenderEnum | undefined;
    birthDate?: Date | undefined;
    zoneInfo?: string | undefined;
    locale?: string | undefined;
    userRoles?: UpdateUserCommandUserRoleDto[] | undefined;

    constructor(data?: IUpdateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.givenName = _data["givenName"];
            this.familyName = _data["familyName"];
            this.middleName = _data["middleName"];
            this.email = _data["email"];
            this.gender = _data["gender"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.zoneInfo = _data["zoneInfo"];
            this.locale = _data["locale"];
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UpdateUserCommandUserRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["givenName"] = this.givenName;
        data["familyName"] = this.familyName;
        data["middleName"] = this.middleName;
        data["email"] = this.email;
        data["gender"] = this.gender;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["zoneInfo"] = this.zoneInfo;
        data["locale"] = this.locale;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpdateUserCommand {
        const json = this.toJSON();
        let result = new UpdateUserCommand();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserCommand {
    givenName?: string | undefined;
    familyName?: string | undefined;
    middleName?: string | undefined;
    email?: string | undefined;
    gender?: GenderEnum | undefined;
    birthDate?: Date | undefined;
    zoneInfo?: string | undefined;
    locale?: string | undefined;
    userRoles?: UpdateUserCommandUserRoleDto[] | undefined;
}

export class UpdateUserCommandUserRoleDto implements IUpdateUserCommandUserRoleDto {
    roleId!: string;

    constructor(data?: IUpdateUserCommandUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): UpdateUserCommandUserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommandUserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        return data;
    }

    clone(): UpdateUserCommandUserRoleDto {
        const json = this.toJSON();
        let result = new UpdateUserCommandUserRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserCommandUserRoleDto {
    roleId: string;
}

export class DeleteUserCommand implements IDeleteUserCommand {

    constructor(data?: IDeleteUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): DeleteUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): DeleteUserCommand {
        const json = this.toJSON();
        let result = new DeleteUserCommand();
        result.init(json);
        return result;
    }
}

export interface IDeleteUserCommand {
}

export class GetUserAuditlogQueryResult extends BasePaginatedResult implements IGetUserAuditlogQueryResult {
    userId!: string;
    auditlogs?: AuditlogDto[] | undefined;

    constructor(data?: IGetUserAuditlogQueryResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userId = _data["userId"];
            if (Array.isArray(_data["auditlogs"])) {
                this.auditlogs = [] as any;
                for (let item of _data["auditlogs"])
                    this.auditlogs!.push(AuditlogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserAuditlogQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserAuditlogQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        if (Array.isArray(this.auditlogs)) {
            data["auditlogs"] = [];
            for (let item of this.auditlogs)
                data["auditlogs"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): GetUserAuditlogQueryResult {
        const json = this.toJSON();
        let result = new GetUserAuditlogQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetUserAuditlogQueryResult extends IBasePaginatedResult {
    userId: string;
    auditlogs?: AuditlogDto[] | undefined;
}

export class UserLookupQueryResult extends BasePaginatedResult implements IUserLookupQueryResult {
    users?: UserLookupDto[] | undefined;

    constructor(data?: IUserLookupQueryResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UserLookupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserLookupQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserLookupQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }

    clone(): UserLookupQueryResult {
        const json = this.toJSON();
        let result = new UserLookupQueryResult();
        result.init(json);
        return result;
    }
}

export interface IUserLookupQueryResult extends IBasePaginatedResult {
    users?: UserLookupDto[] | undefined;
}

export class UserLookupDto implements IUserLookupDto {
    id!: string;
    fullname?: string | undefined;

    constructor(data?: IUserLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullname = _data["fullname"];
        }
    }

    static fromJS(data: any): UserLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullname"] = this.fullname;
        return data;
    }

    clone(): UserLookupDto {
        const json = this.toJSON();
        let result = new UserLookupDto();
        result.init(json);
        return result;
    }
}

export interface IUserLookupDto {
    id: string;
    fullname?: string | undefined;
}

export enum UserLookupOrderByEnum {
    FamilyName = 0,
    Fullname = 1,
}

export class IsEmailAvailableQueryResult implements IIsEmailAvailableQueryResult {
    isEmailAvailable!: boolean;

    constructor(data?: IIsEmailAvailableQueryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEmailAvailable = _data["isEmailAvailable"];
        }
    }

    static fromJS(data: any): IsEmailAvailableQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new IsEmailAvailableQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailAvailable"] = this.isEmailAvailable;
        return data;
    }

    clone(): IsEmailAvailableQueryResult {
        const json = this.toJSON();
        let result = new IsEmailAvailableQueryResult();
        result.init(json);
        return result;
    }
}

export interface IIsEmailAvailableQueryResult {
    isEmailAvailable: boolean;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}