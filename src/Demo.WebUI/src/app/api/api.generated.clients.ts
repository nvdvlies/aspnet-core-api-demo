/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.1.0 (NJsonSchema v10.4.3.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
// @ts-nocheck

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class ApiApplicationSettingsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(query?: GetApplicationSettingsQuery | null | undefined): Observable<GetApplicationSettingsQueryResult> {
        let url_ = this.baseUrl + "/api/ApplicationSettings?";
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GetApplicationSettingsQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetApplicationSettingsQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetApplicationSettingsQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetApplicationSettingsQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetApplicationSettingsQueryResult>(<any>null);
    }

    save(command: SaveApplicationSettingsCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/ApplicationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getApplicationSettingsAuditlog(pageIndex?: number | undefined, pageSize?: number | undefined): Observable<GetApplicationSettingsAuditlogQueryResult> {
        let url_ = this.baseUrl + "/api/ApplicationSettings/Auditlog?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApplicationSettingsAuditlog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApplicationSettingsAuditlog(<any>response_);
                } catch (e) {
                    return <Observable<GetApplicationSettingsAuditlogQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetApplicationSettingsAuditlogQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetApplicationSettingsAuditlog(response: HttpResponseBase): Observable<GetApplicationSettingsAuditlogQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetApplicationSettingsAuditlogQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetApplicationSettingsAuditlogQueryResult>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiCustomersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    search(orderBy?: SearchCustomersOrderByEnum | undefined, orderByDescending?: boolean | undefined, pageIndex?: number | undefined, pageSize?: number | undefined, name?: string | null | undefined): Observable<SearchCustomersQueryResult> {
        let url_ = this.baseUrl + "/api/Customers?";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderByDescending === null)
            throw new Error("The parameter 'orderByDescending' cannot be null.");
        else if (orderByDescending !== undefined)
            url_ += "OrderByDescending=" + encodeURIComponent("" + orderByDescending) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<SearchCustomersQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SearchCustomersQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SearchCustomersQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchCustomersQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchCustomersQueryResult>(<any>null);
    }

    create(command: CreateCustomerCommand): Observable<CreateCustomerResponse> {
        let url_ = this.baseUrl + "/api/Customers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CreateCustomerResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateCustomerResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateCustomerResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreateCustomerResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateCustomerResponse>(<any>null);
    }

    getCustomerById(id: string): Observable<GetCustomerByIdQueryResult> {
        let url_ = this.baseUrl + "/api/Customers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerById(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerByIdQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerByIdQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerById(response: HttpResponseBase): Observable<GetCustomerByIdQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerByIdQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerByIdQueryResult>(<any>null);
    }

    update(id: string, command: UpdateCustomerCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Customers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    delete(id: string, command: DeleteCustomerCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Customers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getCustomerAuditlog(id: string, pageIndex?: number | undefined, pageSize?: number | undefined): Observable<GetCustomerAuditlogQueryResult> {
        let url_ = this.baseUrl + "/api/Customers/{id}/Auditlog?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerAuditlog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerAuditlog(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerAuditlogQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerAuditlogQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerAuditlog(response: HttpResponseBase): Observable<GetCustomerAuditlogQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerAuditlogQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerAuditlogQueryResult>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiEventsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    post(eventGridEvents: EventGridEvent[]): Observable<void> {
        let url_ = this.baseUrl + "/api/Events";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(eventGridEvents);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiInvoicesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    search(orderBy?: SearchInvoicesOrderByEnum | undefined, orderByDescending?: boolean | undefined, pageIndex?: number | undefined, pageSize?: number | undefined, invoiceNumber?: string | null | undefined): Observable<SearchInvoicesQueryResult> {
        let url_ = this.baseUrl + "/api/Invoices?";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderByDescending === null)
            throw new Error("The parameter 'orderByDescending' cannot be null.");
        else if (orderByDescending !== undefined)
            url_ += "OrderByDescending=" + encodeURIComponent("" + orderByDescending) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (invoiceNumber !== undefined && invoiceNumber !== null)
            url_ += "InvoiceNumber=" + encodeURIComponent("" + invoiceNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<SearchInvoicesQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SearchInvoicesQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SearchInvoicesQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchInvoicesQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchInvoicesQueryResult>(<any>null);
    }

    create(command: CreateInvoiceCommand): Observable<CreateInvoiceResponse> {
        let url_ = this.baseUrl + "/api/Invoices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CreateInvoiceResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateInvoiceResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateInvoiceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreateInvoiceResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateInvoiceResponse>(<any>null);
    }

    getInvoiceById(id: string): Observable<GetInvoiceByIdQueryResult> {
        let url_ = this.baseUrl + "/api/Invoices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceById(<any>response_);
                } catch (e) {
                    return <Observable<GetInvoiceByIdQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetInvoiceByIdQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceById(response: HttpResponseBase): Observable<GetInvoiceByIdQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInvoiceByIdQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInvoiceByIdQueryResult>(<any>null);
    }

    update(id: string, command: UpdateInvoiceCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Invoices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    delete(id: string, command: DeleteInvoiceCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Invoices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    markAsSent(id: string, command: MarkInvoiceAsSentCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Invoices/{id}/MarkAsSent";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAsSent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsSent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAsSent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    markAsPaid(id: string, command: MarkInvoiceAsPaidCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Invoices/{id}/MarkAsPaid";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAsPaid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsPaid(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAsPaid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    markAsCancelled(id: string, command: MarkInvoiceAsCancelledCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Invoices/{id}/MarkAsCancelled";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAsCancelled(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsCancelled(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAsCancelled(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getInvoiceAuditlog(id: string, pageIndex?: number | undefined, pageSize?: number | undefined): Observable<GetInvoiceAuditlogQueryResult> {
        let url_ = this.baseUrl + "/api/Invoices/{id}/Auditlog?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceAuditlog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceAuditlog(<any>response_);
                } catch (e) {
                    return <Observable<GetInvoiceAuditlogQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetInvoiceAuditlogQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceAuditlog(response: HttpResponseBase): Observable<GetInvoiceAuditlogQueryResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInvoiceAuditlogQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInvoiceAuditlogQueryResult>(<any>null);
    }

    copy(id: string, command: CopyInvoiceCommand): Observable<CopyInvoiceResponse> {
        let url_ = this.baseUrl + "/api/Invoices/{id}/Copy";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCopy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopy(<any>response_);
                } catch (e) {
                    return <Observable<CopyInvoiceResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CopyInvoiceResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCopy(response: HttpResponseBase): Observable<CopyInvoiceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CopyInvoiceResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CopyInvoiceResponse>(<any>null);
    }

    credit(id: string, command: CreditInvoiceCommand): Observable<CreditInvoiceResponse> {
        let url_ = this.baseUrl + "/api/Invoices/{id}/Credit";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCredit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCredit(<any>response_);
                } catch (e) {
                    return <Observable<CreditInvoiceResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreditInvoiceResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCredit(response: HttpResponseBase): Observable<CreditInvoiceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreditInvoiceResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreditInvoiceResponse>(<any>null);
    }
}

export class GetApplicationSettingsQueryResult implements IGetApplicationSettingsQueryResult {
    applicationSettings?: ApplicationSettingsDto | undefined;

    constructor(data?: IGetApplicationSettingsQueryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationSettings = _data["applicationSettings"] ? ApplicationSettingsDto.fromJS(_data["applicationSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetApplicationSettingsQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetApplicationSettingsQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationSettings"] = this.applicationSettings ? this.applicationSettings.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetApplicationSettingsQueryResult {
        const json = this.toJSON();
        let result = new GetApplicationSettingsQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetApplicationSettingsQueryResult {
    applicationSettings?: ApplicationSettingsDto | undefined;
}

export class EntityDto implements IEntityDto {
    id!: string;
    timestamp?: string | undefined;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.timestamp = _data["timestamp"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["timestamp"] = this.timestamp;
        return data; 
    }

    clone(): EntityDto {
        const json = this.toJSON();
        let result = new EntityDto();
        result.init(json);
        return result;
    }
}

export interface IEntityDto {
    id: string;
    timestamp?: string | undefined;
}

export class AuditableEntityDto extends EntityDto implements IAuditableEntityDto {
    createdBy?: string | undefined;
    createdOn!: Date;
    lastModifiedBy?: string | undefined;
    lastModifiedOn?: Date | undefined;

    constructor(data?: IAuditableEntityDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedOn = _data["lastModifiedOn"] ? new Date(_data["lastModifiedOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuditableEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditableEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedOn"] = this.lastModifiedOn ? this.lastModifiedOn.toISOString() : <any>undefined;
        super.toJSON(data);
        return data; 
    }

    clone(): AuditableEntityDto {
        const json = this.toJSON();
        let result = new AuditableEntityDto();
        result.init(json);
        return result;
    }
}

export interface IAuditableEntityDto extends IEntityDto {
    createdBy?: string | undefined;
    createdOn: Date;
    lastModifiedBy?: string | undefined;
    lastModifiedOn?: Date | undefined;
}

export class ApplicationSettingsDto extends AuditableEntityDto implements IApplicationSettingsDto {
    settings?: ApplicationSettingsSettingsDto | undefined;

    constructor(data?: IApplicationSettingsDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.settings = _data["settings"] ? ApplicationSettingsSettingsDto.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }

    clone(): ApplicationSettingsDto {
        const json = this.toJSON();
        let result = new ApplicationSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationSettingsDto extends IAuditableEntityDto {
    settings?: ApplicationSettingsSettingsDto | undefined;
}

export class ApplicationSettingsSettingsDto implements IApplicationSettingsSettingsDto {
    setting1!: boolean;
    setting2?: string | undefined;
    setting3!: Date;
    setting4!: string;
    setting5!: number;

    constructor(data?: IApplicationSettingsSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setting1 = _data["setting1"];
            this.setting2 = _data["setting2"];
            this.setting3 = _data["setting3"] ? new Date(_data["setting3"].toString()) : <any>undefined;
            this.setting4 = _data["setting4"];
            this.setting5 = _data["setting5"];
        }
    }

    static fromJS(data: any): ApplicationSettingsSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationSettingsSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting1"] = this.setting1;
        data["setting2"] = this.setting2;
        data["setting3"] = this.setting3 ? this.setting3.toISOString() : <any>undefined;
        data["setting4"] = this.setting4;
        data["setting5"] = this.setting5;
        return data; 
    }

    clone(): ApplicationSettingsSettingsDto {
        const json = this.toJSON();
        let result = new ApplicationSettingsSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationSettingsSettingsDto {
    setting1: boolean;
    setting2?: string | undefined;
    setting3: Date;
    setting4: string;
    setting5: number;
}

/** A machine-readable format for specifying errors in HTTP API responses based on https://tools.ietf.org/html/rfc7807. */
export class ProblemDetails implements IProblemDetails {
    /** A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when
dereferenced, it provide human-readable documentation for the problem type
(e.g., using HTML [W3C.REC-html5-20141028]).  When this member is not present, its value is assumed to be
"about:blank". */
    type?: string | undefined;
    /** A short, human-readable summary of the problem type.It SHOULD NOT change from occurrence to occurrence
of the problem, except for purposes of localization(e.g., using proactive content negotiation;
see[RFC7231], Section 3.4). */
    title?: string | undefined;
    /** The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem. */
    status?: number | undefined;
    /** A human-readable explanation specific to this occurrence of the problem. */
    detail?: string | undefined;
    /** A URI reference that identifies the specific occurrence of the problem.It may or may not yield further information if dereferenced. */
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data; 
    }

    clone(): ProblemDetails {
        const json = this.toJSON();
        let result = new ProblemDetails();
        result.init(json);
        return result;
    }
}

/** A machine-readable format for specifying errors in HTTP API responses based on https://tools.ietf.org/html/rfc7807. */
export interface IProblemDetails {
    /** A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when
dereferenced, it provide human-readable documentation for the problem type
(e.g., using HTML [W3C.REC-html5-20141028]).  When this member is not present, its value is assumed to be
"about:blank". */
    type?: string | undefined;
    /** A short, human-readable summary of the problem type.It SHOULD NOT change from occurrence to occurrence
of the problem, except for purposes of localization(e.g., using proactive content negotiation;
see[RFC7231], Section 3.4). */
    title?: string | undefined;
    /** The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem. */
    status?: number | undefined;
    /** A human-readable explanation specific to this occurrence of the problem. */
    detail?: string | undefined;
    /** A URI reference that identifies the specific occurrence of the problem.It may or may not yield further information if dereferenced. */
    instance?: string | undefined;
}

export class GetApplicationSettingsQuery implements IGetApplicationSettingsQuery {

    constructor(data?: IGetApplicationSettingsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetApplicationSettingsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetApplicationSettingsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): GetApplicationSettingsQuery {
        const json = this.toJSON();
        let result = new GetApplicationSettingsQuery();
        result.init(json);
        return result;
    }
}

export interface IGetApplicationSettingsQuery {
}

/** A ProblemDetails for validation errors. */
export class ValidationProblemDetails extends ProblemDetails implements IValidationProblemDetails {
    /** Gets the validation errors associated with this instance of ValidationProblemDetails. */
    errors?: { [key: string]: string[]; } | undefined;

    constructor(data?: IValidationProblemDetails) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = this.errors[key];
            }
        }
        super.toJSON(data);
        return data; 
    }

    clone(): ValidationProblemDetails {
        const json = this.toJSON();
        let result = new ValidationProblemDetails();
        result.init(json);
        return result;
    }
}

/** A ProblemDetails for validation errors. */
export interface IValidationProblemDetails extends IProblemDetails {
    /** Gets the validation errors associated with this instance of ValidationProblemDetails. */
    errors?: { [key: string]: string[]; } | undefined;
}

export class SaveApplicationSettingsCommand implements ISaveApplicationSettingsCommand {
    timestamp?: string | undefined;
    settings?: SaveApplicationSettingsSettingsDto | undefined;

    constructor(data?: ISaveApplicationSettingsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"];
            this.settings = _data["settings"] ? SaveApplicationSettingsSettingsDto.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SaveApplicationSettingsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SaveApplicationSettingsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp;
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        return data; 
    }

    clone(): SaveApplicationSettingsCommand {
        const json = this.toJSON();
        let result = new SaveApplicationSettingsCommand();
        result.init(json);
        return result;
    }
}

export interface ISaveApplicationSettingsCommand {
    timestamp?: string | undefined;
    settings?: SaveApplicationSettingsSettingsDto | undefined;
}

export class SaveApplicationSettingsSettingsDto implements ISaveApplicationSettingsSettingsDto {
    setting1!: boolean;
    setting2?: string | undefined;
    setting3!: Date;
    setting4!: string;
    setting5!: number;

    constructor(data?: ISaveApplicationSettingsSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setting1 = _data["setting1"];
            this.setting2 = _data["setting2"];
            this.setting3 = _data["setting3"] ? new Date(_data["setting3"].toString()) : <any>undefined;
            this.setting4 = _data["setting4"];
            this.setting5 = _data["setting5"];
        }
    }

    static fromJS(data: any): SaveApplicationSettingsSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveApplicationSettingsSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting1"] = this.setting1;
        data["setting2"] = this.setting2;
        data["setting3"] = this.setting3 ? this.setting3.toISOString() : <any>undefined;
        data["setting4"] = this.setting4;
        data["setting5"] = this.setting5;
        return data; 
    }

    clone(): SaveApplicationSettingsSettingsDto {
        const json = this.toJSON();
        let result = new SaveApplicationSettingsSettingsDto();
        result.init(json);
        return result;
    }
}

export interface ISaveApplicationSettingsSettingsDto {
    setting1: boolean;
    setting2?: string | undefined;
    setting3: Date;
    setting4: string;
    setting5: number;
}

export class BasePaginatedResult implements IBasePaginatedResult {
    pageIndex!: number;
    pageSize!: number;
    totalItems!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IBasePaginatedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.totalItems = _data["totalItems"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): BasePaginatedResult {
        data = typeof data === 'object' ? data : {};
        let result = new BasePaginatedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["totalItems"] = this.totalItems;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }

    clone(): BasePaginatedResult {
        const json = this.toJSON();
        let result = new BasePaginatedResult();
        result.init(json);
        return result;
    }
}

export interface IBasePaginatedResult {
    pageIndex: number;
    pageSize: number;
    totalItems: number;
    totalPages: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class GetApplicationSettingsAuditlogQueryResult extends BasePaginatedResult implements IGetApplicationSettingsAuditlogQueryResult {
    auditlogs?: AuditlogDto[] | undefined;

    constructor(data?: IGetApplicationSettingsAuditlogQueryResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["auditlogs"])) {
                this.auditlogs = [] as any;
                for (let item of _data["auditlogs"])
                    this.auditlogs!.push(AuditlogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetApplicationSettingsAuditlogQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetApplicationSettingsAuditlogQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.auditlogs)) {
            data["auditlogs"] = [];
            for (let item of this.auditlogs)
                data["auditlogs"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): GetApplicationSettingsAuditlogQueryResult {
        const json = this.toJSON();
        let result = new GetApplicationSettingsAuditlogQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetApplicationSettingsAuditlogQueryResult extends IBasePaginatedResult {
    auditlogs?: AuditlogDto[] | undefined;
}

export class AuditlogDto extends EntityDto implements IAuditlogDto {
    modifiedBy?: string | undefined;
    modifiedOn!: Date;
    auditlogItems?: AuditlogItemDto[] | undefined;

    constructor(data?: IAuditlogDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.modifiedBy = _data["modifiedBy"];
            this.modifiedOn = _data["modifiedOn"] ? new Date(_data["modifiedOn"].toString()) : <any>undefined;
            if (Array.isArray(_data["auditlogItems"])) {
                this.auditlogItems = [] as any;
                for (let item of _data["auditlogItems"])
                    this.auditlogItems!.push(AuditlogItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuditlogDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditlogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedOn"] = this.modifiedOn ? this.modifiedOn.toISOString() : <any>undefined;
        if (Array.isArray(this.auditlogItems)) {
            data["auditlogItems"] = [];
            for (let item of this.auditlogItems)
                data["auditlogItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): AuditlogDto {
        const json = this.toJSON();
        let result = new AuditlogDto();
        result.init(json);
        return result;
    }
}

export interface IAuditlogDto extends IEntityDto {
    modifiedBy?: string | undefined;
    modifiedOn: Date;
    auditlogItems?: AuditlogItemDto[] | undefined;
}

export class AuditlogItemDto extends EntityDto implements IAuditlogItemDto {
    propertyName?: string | undefined;
    status!: AuditlogStatusEnum;
    type!: AuditlogTypeEnum;
    currentValueAsString?: string | undefined;
    previousValueAsString?: string | undefined;
    auditlogItems?: AuditlogItemDto[] | undefined;

    constructor(data?: IAuditlogItemDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.status = _data["status"];
            this.type = _data["type"];
            this.currentValueAsString = _data["currentValueAsString"];
            this.previousValueAsString = _data["previousValueAsString"];
            if (Array.isArray(_data["auditlogItems"])) {
                this.auditlogItems = [] as any;
                for (let item of _data["auditlogItems"])
                    this.auditlogItems!.push(AuditlogItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuditlogItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditlogItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["status"] = this.status;
        data["type"] = this.type;
        data["currentValueAsString"] = this.currentValueAsString;
        data["previousValueAsString"] = this.previousValueAsString;
        if (Array.isArray(this.auditlogItems)) {
            data["auditlogItems"] = [];
            for (let item of this.auditlogItems)
                data["auditlogItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): AuditlogItemDto {
        const json = this.toJSON();
        let result = new AuditlogItemDto();
        result.init(json);
        return result;
    }
}

export interface IAuditlogItemDto extends IEntityDto {
    propertyName?: string | undefined;
    status: AuditlogStatusEnum;
    type: AuditlogTypeEnum;
    currentValueAsString?: string | undefined;
    previousValueAsString?: string | undefined;
    auditlogItems?: AuditlogItemDto[] | undefined;
}

export enum AuditlogStatusEnum {
    Unchanged = 0,
    Added = 1,
    Updated = 2,
    Removed = 3,
}

export enum AuditlogTypeEnum {
    None = 0,
    Text = 1,
    Date = 2,
    DateTime = 3,
    Time = 4,
    Currency = 5,
    Decimal = 6,
    Number = 7,
    OnOff = 8,
    YesNo = 9,
}

export class SearchCustomersQueryResult extends BasePaginatedResult implements ISearchCustomersQueryResult {
    customers?: SearchCustomerDto[] | undefined;

    constructor(data?: ISearchCustomersQueryResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["customers"])) {
                this.customers = [] as any;
                for (let item of _data["customers"])
                    this.customers!.push(SearchCustomerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchCustomersQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchCustomersQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customers)) {
            data["customers"] = [];
            for (let item of this.customers)
                data["customers"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): SearchCustomersQueryResult {
        const json = this.toJSON();
        let result = new SearchCustomersQueryResult();
        result.init(json);
        return result;
    }
}

export interface ISearchCustomersQueryResult extends IBasePaginatedResult {
    customers?: SearchCustomerDto[] | undefined;
}

export class SearchCustomerDto implements ISearchCustomerDto {
    id!: string;
    code!: number;
    name?: string | undefined;

    constructor(data?: ISearchCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SearchCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }

    clone(): SearchCustomerDto {
        const json = this.toJSON();
        let result = new SearchCustomerDto();
        result.init(json);
        return result;
    }
}

export interface ISearchCustomerDto {
    id: string;
    code: number;
    name?: string | undefined;
}

export enum SearchCustomersOrderByEnum {
    Code = 0,
    Name = 1,
}

export class GetCustomerByIdQueryResult implements IGetCustomerByIdQueryResult {
    customer?: CustomerDto | undefined;

    constructor(data?: IGetCustomerByIdQueryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customer = _data["customer"] ? CustomerDto.fromJS(_data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCustomerByIdQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerByIdQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCustomerByIdQueryResult {
        const json = this.toJSON();
        let result = new GetCustomerByIdQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetCustomerByIdQueryResult {
    customer?: CustomerDto | undefined;
}

export class SoftDeleteEntityDto extends AuditableEntityDto implements ISoftDeleteEntityDto {
    deleted!: boolean;
    deletedBy?: string | undefined;
    deletedOn?: Date | undefined;

    constructor(data?: ISoftDeleteEntityDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.deleted = _data["deleted"];
            this.deletedBy = _data["deletedBy"];
            this.deletedOn = _data["deletedOn"] ? new Date(_data["deletedOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SoftDeleteEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new SoftDeleteEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deleted"] = this.deleted;
        data["deletedBy"] = this.deletedBy;
        data["deletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        super.toJSON(data);
        return data; 
    }

    clone(): SoftDeleteEntityDto {
        const json = this.toJSON();
        let result = new SoftDeleteEntityDto();
        result.init(json);
        return result;
    }
}

export interface ISoftDeleteEntityDto extends IAuditableEntityDto {
    deleted: boolean;
    deletedBy?: string | undefined;
    deletedOn?: Date | undefined;
}

export class CustomerDto extends SoftDeleteEntityDto implements ICustomerDto {
    code!: number;
    name?: string | undefined;

    constructor(data?: ICustomerDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        super.toJSON(data);
        return data; 
    }

    clone(): CustomerDto {
        const json = this.toJSON();
        let result = new CustomerDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerDto extends ISoftDeleteEntityDto {
    code: number;
    name?: string | undefined;
}

export class CreateCustomerResponse implements ICreateCustomerResponse {
    id!: string;

    constructor(data?: ICreateCustomerResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateCustomerResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateCustomerResponse {
        const json = this.toJSON();
        let result = new CreateCustomerResponse();
        result.init(json);
        return result;
    }
}

export interface ICreateCustomerResponse {
    id: string;
}

export class CreateCustomerCommand implements ICreateCustomerCommand {
    name?: string | undefined;

    constructor(data?: ICreateCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): CreateCustomerCommand {
        const json = this.toJSON();
        let result = new CreateCustomerCommand();
        result.init(json);
        return result;
    }
}

export interface ICreateCustomerCommand {
    name?: string | undefined;
}

export class UpdateCustomerCommand implements IUpdateCustomerCommand {
    timestamp?: string | undefined;
    name?: string | undefined;

    constructor(data?: IUpdateCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp;
        data["name"] = this.name;
        return data; 
    }

    clone(): UpdateCustomerCommand {
        const json = this.toJSON();
        let result = new UpdateCustomerCommand();
        result.init(json);
        return result;
    }
}

export interface IUpdateCustomerCommand {
    timestamp?: string | undefined;
    name?: string | undefined;
}

export class DeleteCustomerCommand implements IDeleteCustomerCommand {

    constructor(data?: IDeleteCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): DeleteCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): DeleteCustomerCommand {
        const json = this.toJSON();
        let result = new DeleteCustomerCommand();
        result.init(json);
        return result;
    }
}

export interface IDeleteCustomerCommand {
}

export class GetCustomerAuditlogQueryResult extends BasePaginatedResult implements IGetCustomerAuditlogQueryResult {
    customerId!: string;
    auditlogs?: AuditlogDto[] | undefined;

    constructor(data?: IGetCustomerAuditlogQueryResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customerId = _data["customerId"];
            if (Array.isArray(_data["auditlogs"])) {
                this.auditlogs = [] as any;
                for (let item of _data["auditlogs"])
                    this.auditlogs!.push(AuditlogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetCustomerAuditlogQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerAuditlogQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        if (Array.isArray(this.auditlogs)) {
            data["auditlogs"] = [];
            for (let item of this.auditlogs)
                data["auditlogs"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): GetCustomerAuditlogQueryResult {
        const json = this.toJSON();
        let result = new GetCustomerAuditlogQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetCustomerAuditlogQueryResult extends IBasePaginatedResult {
    customerId: string;
    auditlogs?: AuditlogDto[] | undefined;
}

/** Properties of an event published to an Event Grid topic using the EventGrid Schema. */
export class EventGridEvent implements IEventGridEvent {
    /** Gets or sets the event payload as BinaryData. Using BinaryData,
one can deserialize the payload into rich data, or access the raw JSON data using ToString. */
    data?: BinaryData | undefined;
    /** Gets or sets a unique identifier for the event.  */
    id?: string | undefined;
    /** Gets or sets the resource path of the event source.
            This must be set when publishing the event to a domain, and must not be set when publishing the event to a topic.
             */
    topic?: string | undefined;
    /** Gets or sets a resource path relative to the topic path. */
    subject?: string | undefined;
    /** Gets or sets the type of the event that occurred. */
    eventType?: string | undefined;
    /** Gets or sets the time (in UTC) the event was generated. */
    eventTime!: Date;
    /** Gets or sets the schema version of the data object. */
    dataVersion?: string | undefined;

    constructor(data?: IEventGridEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? BinaryData.fromJS(_data["data"]) : <any>undefined;
            this.id = _data["id"];
            this.topic = _data["topic"];
            this.subject = _data["subject"];
            this.eventType = _data["eventType"];
            this.eventTime = _data["eventTime"] ? new Date(_data["eventTime"].toString()) : <any>undefined;
            this.dataVersion = _data["dataVersion"];
        }
    }

    static fromJS(data: any): EventGridEvent {
        data = typeof data === 'object' ? data : {};
        let result = new EventGridEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["topic"] = this.topic;
        data["subject"] = this.subject;
        data["eventType"] = this.eventType;
        data["eventTime"] = this.eventTime ? this.eventTime.toISOString() : <any>undefined;
        data["dataVersion"] = this.dataVersion;
        return data; 
    }

    clone(): EventGridEvent {
        const json = this.toJSON();
        let result = new EventGridEvent();
        result.init(json);
        return result;
    }
}

/** Properties of an event published to an Event Grid topic using the EventGrid Schema. */
export interface IEventGridEvent {
    /** Gets or sets the event payload as BinaryData. Using BinaryData,
one can deserialize the payload into rich data, or access the raw JSON data using ToString. */
    data?: BinaryData | undefined;
    /** Gets or sets a unique identifier for the event.  */
    id?: string | undefined;
    /** Gets or sets the resource path of the event source.
            This must be set when publishing the event to a domain, and must not be set when publishing the event to a topic.
             */
    topic?: string | undefined;
    /** Gets or sets a resource path relative to the topic path. */
    subject?: string | undefined;
    /** Gets or sets the type of the event that occurred. */
    eventType?: string | undefined;
    /** Gets or sets the time (in UTC) the event was generated. */
    eventTime: Date;
    /** Gets or sets the schema version of the data object. */
    dataVersion?: string | undefined;
}

/** A lightweight abstraction for a payload of bytes that supports converting between string, stream, JSON, and bytes. */
export class BinaryData implements IBinaryData {

    constructor(data?: IBinaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): BinaryData {
        data = typeof data === 'object' ? data : {};
        let result = new BinaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): BinaryData {
        const json = this.toJSON();
        let result = new BinaryData();
        result.init(json);
        return result;
    }
}

/** A lightweight abstraction for a payload of bytes that supports converting between string, stream, JSON, and bytes. */
export interface IBinaryData {
}

export class SearchInvoicesQueryResult extends BasePaginatedResult implements ISearchInvoicesQueryResult {
    invoices?: SearchInvoiceDto[] | undefined;

    constructor(data?: ISearchInvoicesQueryResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["invoices"])) {
                this.invoices = [] as any;
                for (let item of _data["invoices"])
                    this.invoices!.push(SearchInvoiceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchInvoicesQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchInvoicesQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.invoices)) {
            data["invoices"] = [];
            for (let item of this.invoices)
                data["invoices"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): SearchInvoicesQueryResult {
        const json = this.toJSON();
        let result = new SearchInvoicesQueryResult();
        result.init(json);
        return result;
    }
}

export interface ISearchInvoicesQueryResult extends IBasePaginatedResult {
    invoices?: SearchInvoiceDto[] | undefined;
}

export class SearchInvoiceDto extends SoftDeleteEntityDto implements ISearchInvoiceDto {
    invoiceNumber?: string | undefined;
    customerId!: string;
    invoiceDate!: Date;
    paymentTerm!: number;
    orderReference?: string | undefined;
    status!: InvoiceStatusEnum;

    constructor(data?: ISearchInvoiceDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.invoiceNumber = _data["invoiceNumber"];
            this.customerId = _data["customerId"];
            this.invoiceDate = _data["invoiceDate"] ? new Date(_data["invoiceDate"].toString()) : <any>undefined;
            this.paymentTerm = _data["paymentTerm"];
            this.orderReference = _data["orderReference"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): SearchInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceNumber"] = this.invoiceNumber;
        data["customerId"] = this.customerId;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["paymentTerm"] = this.paymentTerm;
        data["orderReference"] = this.orderReference;
        data["status"] = this.status;
        super.toJSON(data);
        return data; 
    }

    clone(): SearchInvoiceDto {
        const json = this.toJSON();
        let result = new SearchInvoiceDto();
        result.init(json);
        return result;
    }
}

export interface ISearchInvoiceDto extends ISoftDeleteEntityDto {
    invoiceNumber?: string | undefined;
    customerId: string;
    invoiceDate: Date;
    paymentTerm: number;
    orderReference?: string | undefined;
    status: InvoiceStatusEnum;
}

export enum InvoiceStatusEnum {
    Draft = 0,
    Sent = 1,
    Paid = 2,
    Cancelled = 3,
}

export enum SearchInvoicesOrderByEnum {
    InvoiceNumber = 0,
    InvoiceDate = 1,
}

export class GetInvoiceByIdQueryResult implements IGetInvoiceByIdQueryResult {
    invoice?: InvoiceDto | undefined;

    constructor(data?: IGetInvoiceByIdQueryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoice = _data["invoice"] ? InvoiceDto.fromJS(_data["invoice"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetInvoiceByIdQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetInvoiceByIdQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetInvoiceByIdQueryResult {
        const json = this.toJSON();
        let result = new GetInvoiceByIdQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetInvoiceByIdQueryResult {
    invoice?: InvoiceDto | undefined;
}

export class InvoiceDto extends SoftDeleteEntityDto implements IInvoiceDto {
    invoiceNumber?: string | undefined;
    customerId!: string;
    invoiceDate!: Date;
    paymentTerm!: number;
    orderReference?: string | undefined;
    status!: InvoiceStatusEnum;
    pdfIsSynced!: boolean;
    pdfDataChecksum?: string | undefined;
    invoiceLines?: InvoiceLineDto[] | undefined;

    constructor(data?: IInvoiceDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.invoiceNumber = _data["invoiceNumber"];
            this.customerId = _data["customerId"];
            this.invoiceDate = _data["invoiceDate"] ? new Date(_data["invoiceDate"].toString()) : <any>undefined;
            this.paymentTerm = _data["paymentTerm"];
            this.orderReference = _data["orderReference"];
            this.status = _data["status"];
            this.pdfIsSynced = _data["pdfIsSynced"];
            this.pdfDataChecksum = _data["pdfDataChecksum"];
            if (Array.isArray(_data["invoiceLines"])) {
                this.invoiceLines = [] as any;
                for (let item of _data["invoiceLines"])
                    this.invoiceLines!.push(InvoiceLineDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceNumber"] = this.invoiceNumber;
        data["customerId"] = this.customerId;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["paymentTerm"] = this.paymentTerm;
        data["orderReference"] = this.orderReference;
        data["status"] = this.status;
        data["pdfIsSynced"] = this.pdfIsSynced;
        data["pdfDataChecksum"] = this.pdfDataChecksum;
        if (Array.isArray(this.invoiceLines)) {
            data["invoiceLines"] = [];
            for (let item of this.invoiceLines)
                data["invoiceLines"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): InvoiceDto {
        const json = this.toJSON();
        let result = new InvoiceDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDto extends ISoftDeleteEntityDto {
    invoiceNumber?: string | undefined;
    customerId: string;
    invoiceDate: Date;
    paymentTerm: number;
    orderReference?: string | undefined;
    status: InvoiceStatusEnum;
    pdfIsSynced: boolean;
    pdfDataChecksum?: string | undefined;
    invoiceLines?: InvoiceLineDto[] | undefined;
}

export class InvoiceLineDto extends EntityDto implements IInvoiceLineDto {
    lineNumber!: number;
    quantity!: number;
    description?: string | undefined;
    sellingPrice!: number;

    constructor(data?: IInvoiceLineDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.lineNumber = _data["lineNumber"];
            this.quantity = _data["quantity"];
            this.description = _data["description"];
            this.sellingPrice = _data["sellingPrice"];
        }
    }

    static fromJS(data: any): InvoiceLineDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceLineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lineNumber"] = this.lineNumber;
        data["quantity"] = this.quantity;
        data["description"] = this.description;
        data["sellingPrice"] = this.sellingPrice;
        super.toJSON(data);
        return data; 
    }

    clone(): InvoiceLineDto {
        const json = this.toJSON();
        let result = new InvoiceLineDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceLineDto extends IEntityDto {
    lineNumber: number;
    quantity: number;
    description?: string | undefined;
    sellingPrice: number;
}

export class CreateInvoiceResponse implements ICreateInvoiceResponse {
    id!: string;

    constructor(data?: ICreateInvoiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateInvoiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateInvoiceResponse {
        const json = this.toJSON();
        let result = new CreateInvoiceResponse();
        result.init(json);
        return result;
    }
}

export interface ICreateInvoiceResponse {
    id: string;
}

export class CreateInvoiceCommand implements ICreateInvoiceCommand {
    customerId!: string;
    invoiceDate!: Date;
    paymentTerm!: number;
    orderReference?: string | undefined;
    invoiceLines?: CreateInvoiceCommandInvoiceLine[] | undefined;

    constructor(data?: ICreateInvoiceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"];
            this.invoiceDate = _data["invoiceDate"] ? new Date(_data["invoiceDate"].toString()) : <any>undefined;
            this.paymentTerm = _data["paymentTerm"];
            this.orderReference = _data["orderReference"];
            if (Array.isArray(_data["invoiceLines"])) {
                this.invoiceLines = [] as any;
                for (let item of _data["invoiceLines"])
                    this.invoiceLines!.push(CreateInvoiceCommandInvoiceLine.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateInvoiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["paymentTerm"] = this.paymentTerm;
        data["orderReference"] = this.orderReference;
        if (Array.isArray(this.invoiceLines)) {
            data["invoiceLines"] = [];
            for (let item of this.invoiceLines)
                data["invoiceLines"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateInvoiceCommand {
        const json = this.toJSON();
        let result = new CreateInvoiceCommand();
        result.init(json);
        return result;
    }
}

export interface ICreateInvoiceCommand {
    customerId: string;
    invoiceDate: Date;
    paymentTerm: number;
    orderReference?: string | undefined;
    invoiceLines?: CreateInvoiceCommandInvoiceLine[] | undefined;
}

export class CreateInvoiceCommandInvoiceLine implements ICreateInvoiceCommandInvoiceLine {
    quantity!: number;
    description?: string | undefined;
    sellingPrice!: number;

    constructor(data?: ICreateInvoiceCommandInvoiceLine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quantity = _data["quantity"];
            this.description = _data["description"];
            this.sellingPrice = _data["sellingPrice"];
        }
    }

    static fromJS(data: any): CreateInvoiceCommandInvoiceLine {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceCommandInvoiceLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        data["description"] = this.description;
        data["sellingPrice"] = this.sellingPrice;
        return data; 
    }

    clone(): CreateInvoiceCommandInvoiceLine {
        const json = this.toJSON();
        let result = new CreateInvoiceCommandInvoiceLine();
        result.init(json);
        return result;
    }
}

export interface ICreateInvoiceCommandInvoiceLine {
    quantity: number;
    description?: string | undefined;
    sellingPrice: number;
}

export class UpdateInvoiceCommand implements IUpdateInvoiceCommand {
    timestamp?: string | undefined;
    customerId!: string;
    invoiceDate!: Date;
    paymentTerm!: number;
    orderReference?: string | undefined;
    invoiceLines?: UpdateInvoiceCommandInvoiceLine[] | undefined;

    constructor(data?: IUpdateInvoiceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"];
            this.customerId = _data["customerId"];
            this.invoiceDate = _data["invoiceDate"] ? new Date(_data["invoiceDate"].toString()) : <any>undefined;
            this.paymentTerm = _data["paymentTerm"];
            this.orderReference = _data["orderReference"];
            if (Array.isArray(_data["invoiceLines"])) {
                this.invoiceLines = [] as any;
                for (let item of _data["invoiceLines"])
                    this.invoiceLines!.push(UpdateInvoiceCommandInvoiceLine.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateInvoiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInvoiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp;
        data["customerId"] = this.customerId;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["paymentTerm"] = this.paymentTerm;
        data["orderReference"] = this.orderReference;
        if (Array.isArray(this.invoiceLines)) {
            data["invoiceLines"] = [];
            for (let item of this.invoiceLines)
                data["invoiceLines"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UpdateInvoiceCommand {
        const json = this.toJSON();
        let result = new UpdateInvoiceCommand();
        result.init(json);
        return result;
    }
}

export interface IUpdateInvoiceCommand {
    timestamp?: string | undefined;
    customerId: string;
    invoiceDate: Date;
    paymentTerm: number;
    orderReference?: string | undefined;
    invoiceLines?: UpdateInvoiceCommandInvoiceLine[] | undefined;
}

export class UpdateInvoiceCommandInvoiceLine implements IUpdateInvoiceCommandInvoiceLine {
    id?: string | undefined;
    quantity!: number;
    description?: string | undefined;
    sellingPrice!: number;

    constructor(data?: IUpdateInvoiceCommandInvoiceLine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quantity = _data["quantity"];
            this.description = _data["description"];
            this.sellingPrice = _data["sellingPrice"];
        }
    }

    static fromJS(data: any): UpdateInvoiceCommandInvoiceLine {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInvoiceCommandInvoiceLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quantity"] = this.quantity;
        data["description"] = this.description;
        data["sellingPrice"] = this.sellingPrice;
        return data; 
    }

    clone(): UpdateInvoiceCommandInvoiceLine {
        const json = this.toJSON();
        let result = new UpdateInvoiceCommandInvoiceLine();
        result.init(json);
        return result;
    }
}

export interface IUpdateInvoiceCommandInvoiceLine {
    id?: string | undefined;
    quantity: number;
    description?: string | undefined;
    sellingPrice: number;
}

export class DeleteInvoiceCommand implements IDeleteInvoiceCommand {

    constructor(data?: IDeleteInvoiceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): DeleteInvoiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteInvoiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): DeleteInvoiceCommand {
        const json = this.toJSON();
        let result = new DeleteInvoiceCommand();
        result.init(json);
        return result;
    }
}

export interface IDeleteInvoiceCommand {
}

export class MarkInvoiceAsSentCommand implements IMarkInvoiceAsSentCommand {

    constructor(data?: IMarkInvoiceAsSentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): MarkInvoiceAsSentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MarkInvoiceAsSentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): MarkInvoiceAsSentCommand {
        const json = this.toJSON();
        let result = new MarkInvoiceAsSentCommand();
        result.init(json);
        return result;
    }
}

export interface IMarkInvoiceAsSentCommand {
}

export class MarkInvoiceAsPaidCommand implements IMarkInvoiceAsPaidCommand {

    constructor(data?: IMarkInvoiceAsPaidCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): MarkInvoiceAsPaidCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MarkInvoiceAsPaidCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): MarkInvoiceAsPaidCommand {
        const json = this.toJSON();
        let result = new MarkInvoiceAsPaidCommand();
        result.init(json);
        return result;
    }
}

export interface IMarkInvoiceAsPaidCommand {
}

export class MarkInvoiceAsCancelledCommand implements IMarkInvoiceAsCancelledCommand {

    constructor(data?: IMarkInvoiceAsCancelledCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): MarkInvoiceAsCancelledCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MarkInvoiceAsCancelledCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): MarkInvoiceAsCancelledCommand {
        const json = this.toJSON();
        let result = new MarkInvoiceAsCancelledCommand();
        result.init(json);
        return result;
    }
}

export interface IMarkInvoiceAsCancelledCommand {
}

export class GetInvoiceAuditlogQueryResult extends BasePaginatedResult implements IGetInvoiceAuditlogQueryResult {
    invoiceId!: string;
    auditlogs?: AuditlogDto[] | undefined;

    constructor(data?: IGetInvoiceAuditlogQueryResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.invoiceId = _data["invoiceId"];
            if (Array.isArray(_data["auditlogs"])) {
                this.auditlogs = [] as any;
                for (let item of _data["auditlogs"])
                    this.auditlogs!.push(AuditlogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetInvoiceAuditlogQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetInvoiceAuditlogQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceId"] = this.invoiceId;
        if (Array.isArray(this.auditlogs)) {
            data["auditlogs"] = [];
            for (let item of this.auditlogs)
                data["auditlogs"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): GetInvoiceAuditlogQueryResult {
        const json = this.toJSON();
        let result = new GetInvoiceAuditlogQueryResult();
        result.init(json);
        return result;
    }
}

export interface IGetInvoiceAuditlogQueryResult extends IBasePaginatedResult {
    invoiceId: string;
    auditlogs?: AuditlogDto[] | undefined;
}

export class CopyInvoiceResponse implements ICopyInvoiceResponse {
    id!: string;

    constructor(data?: ICopyInvoiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CopyInvoiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CopyInvoiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): CopyInvoiceResponse {
        const json = this.toJSON();
        let result = new CopyInvoiceResponse();
        result.init(json);
        return result;
    }
}

export interface ICopyInvoiceResponse {
    id: string;
}

export class CopyInvoiceCommand implements ICopyInvoiceCommand {

    constructor(data?: ICopyInvoiceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CopyInvoiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CopyInvoiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): CopyInvoiceCommand {
        const json = this.toJSON();
        let result = new CopyInvoiceCommand();
        result.init(json);
        return result;
    }
}

export interface ICopyInvoiceCommand {
}

export class CreditInvoiceResponse implements ICreditInvoiceResponse {
    id!: string;

    constructor(data?: ICreditInvoiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreditInvoiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreditInvoiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): CreditInvoiceResponse {
        const json = this.toJSON();
        let result = new CreditInvoiceResponse();
        result.init(json);
        return result;
    }
}

export interface ICreditInvoiceResponse {
    id: string;
}

export class CreditInvoiceCommand implements ICreditInvoiceCommand {

    constructor(data?: ICreditInvoiceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CreditInvoiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreditInvoiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): CreditInvoiceCommand {
        const json = this.toJSON();
        let result = new CreditInvoiceCommand();
        result.init(json);
        return result;
    }
}

export interface ICreditInvoiceCommand {
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}